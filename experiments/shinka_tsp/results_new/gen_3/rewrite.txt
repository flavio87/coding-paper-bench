# EVOLVE-BLOCK-START
"""
TSP Solver: Multi-start Hybrid with Or-opt and enhanced 2-opt

Combines multiple construction heuristics with aggressive local search
including 2-opt and Or-opt moves.
"""

import numpy as np
import time


def solve_tsp(coords: np.ndarray, time_limit_ms: int = 5000) -> tuple:
    """
    Solve TSP instance.
    """
    n = len(coords)
    if n <= 1:
        return list(range(n)), 0.0
    if n == 2:
        return [0, 1], 2 * np.sqrt(np.sum((coords[0] - coords[1]) ** 2))

    # Vectorized distance matrix computation
    diff = coords[:, np.newaxis, :] - coords[np.newaxis, :, :]
    dist = np.round(np.sqrt(np.sum(diff ** 2, axis=2)))
    
    start_time = time.perf_counter()
    deadline = start_time + time_limit_ms / 1000.0

    def tour_length(tour):
        return sum(dist[tour[i], tour[(i + 1) % n]] for i in range(n))

    def nearest_neighbor(start):
        visited = np.zeros(n, dtype=bool)
        tour = np.zeros(n, dtype=int)
        current = start
        tour[0] = current
        visited[current] = True
        for step in range(1, n):
            dists = dist[current].copy()
            dists[visited] = np.inf
            best_next = np.argmin(dists)
            tour[step] = best_next
            visited[best_next] = True
            current = best_next
        return tour

    def two_opt(tour):
        tour = tour.copy()
        improved = True
        while improved and time.perf_counter() < deadline:
            improved = False
            for i in range(n - 1):
                if time.perf_counter() >= deadline:
                    break
                for j in range(i + 2, n):
                    if j == n - 1 and i == 0:
                        continue
                    a, b = tour[i], tour[i + 1]
                    c, d = tour[j], tour[(j + 1) % n]
                    delta = (dist[a, c] + dist[b, d]) - (dist[a, b] + dist[c, d])
                    if delta < -0.5:
                        tour[i+1:j+1] = tour[i+1:j+1][::-1]
                        improved = True
        return tour

    def or_opt(tour):
        """Relocate segments of 1-3 cities"""
        tour = list(tour)
        improved = True
        while improved and time.perf_counter() < deadline:
            improved = False
            for seg_len in [1, 2, 3]:
                if improved or time.perf_counter() >= deadline:
                    break
                for i in range(n):
                    if improved or time.perf_counter() >= deadline:
                        break
                    if i + seg_len > n:
                        continue
                    # Cost of removing segment
                    prev_i = (i - 1) % n
                    next_seg = (i + seg_len) % n
                    seg_start = tour[i]
                    seg_end = tour[(i + seg_len - 1) % n]
                    
                    removal_cost = dist[tour[prev_i], seg_start] + dist[seg_end, tour[next_seg]]
                    new_edge = dist[tour[prev_i], tour[next_seg]]
                    
                    for j in range(n):
                        if j >= i - 1 and j <= i + seg_len:
                            continue
                        next_j = (j + 1) % n
                        
                        # Cost of inserting segment between j and next_j
                        insert_cost = dist[tour[j], seg_start] + dist[seg_end, tour[next_j]]
                        old_edge = dist[tour[j], tour[next_j]]
                        
                        delta = (new_edge + insert_cost) - (removal_cost + old_edge)
                        
                        if delta < -0.5:
                            # Perform the move
                            segment = [tour[(i + k) % n] for k in range(seg_len)]
                            new_tour = []
                            for k in range(n):
                                if k >= i and k < i + seg_len:
                                    continue
                                new_tour.append(tour[k])
                            
                            # Find insertion point in new_tour
                            if j < i:
                                insert_pos = j + 1
                            else:
                                insert_pos = j - seg_len + 1
                            
                            tour = new_tour[:insert_pos] + segment + new_tour[insert_pos:]
                            improved = True
                            break
        return np.array(tour)

    def full_local_search(tour):
        """Apply 2-opt and or-opt iteratively"""
        best_len = tour_length(tour)
        while time.perf_counter() < deadline:
            tour = two_opt(tour)
            new_len = tour_length(tour)
            if new_len >= best_len - 0.5:
                break
            best_len = new_len
            
            if time.perf_counter() >= deadline:
                break
                
            tour = or_opt(tour)
            new_len = tour_length(tour)
            if new_len >= best_len - 0.5:
                break
            best_len = new_len
        return tour

    # Multi-start: try different starting cities
    best_tour = None
    best_length = np.inf
    
    # Determine how many starts to try based on problem size
    num_starts = min(n, max(5, n // 10))
    start_cities = np.linspace(0, n - 1, num_starts, dtype=int)
    
    for start in start_cities:
        if time.perf_counter() >= deadline:
            break
            
        tour = nearest_neighbor(start)
        tour = full_local_search(tour)
        length = tour_length(tour)
        
        if length < best_length:
            best_length = length
            best_tour = tour.copy()

    # If time remains, do additional improvement on best tour
    remaining = deadline - time.perf_counter()
    if remaining > 0.1 and best_tour is not None:
        best_tour = full_local_search(best_tour)
        best_length = tour_length(best_tour)

    # Final 2-opt pass with remaining time
    if time.perf_counter() < deadline and best_tour is not None:
        best_tour = two_opt(best_tour)
        best_length = tour_length(best_tour)

    return best_tour.tolist(), best_length


# EVOLVE-BLOCK-END


def run_experiment(coords: np.ndarray, time_limit_ms: int = 5000, optimal_length: float = None) -> dict:
    """
    Entry point for ShinkaEvolve evaluation.
    """
    tour, length = solve_tsp(coords, time_limit_ms)

    n = len(coords)
    valid = (len(tour) == n and set(tour) == set(range(n)))

    if optimal_length and optimal_length > 0:
        score = optimal_length / length if length > 0 else 0.0
    else:
        score = 1000.0 / length if length > 0 else 0.0

    return {
        'tour': tour,
        'length': length,
        'valid': valid,
        'score': score
    }