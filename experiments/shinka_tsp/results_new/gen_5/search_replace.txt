Looking at the current implementation, I can see several opportunities for improvement. The Or-opt implementation is quite complex and may have bugs, and the 2-opt could be more efficient. Let me propose a more effective approach:

1. **Faster 2-opt with neighbor lists**: Instead of checking all pairs, prioritize nearby cities
2. **Simpler and more effective Or-opt**: The current Or-opt has complex index handling that may cause issues
3. **Add 3-opt moves**: More powerful local search
4. **Better time allocation**: Spend more time on local search

<NAME>
improved_local_search_with_3opt

</NAME>

<DESCRIPTION>
This improvement focuses on:
1. Replacing the complex Or-opt with a simpler, correct implementation that relocates single cities
2. Adding a limited 3-opt that tries specific promising moves
3. Using a more efficient 2-opt that tracks improvements better
4. Better time management between construction and improvement phases
5. Using don't-look bits to skip cities that haven't been modified recently

The key insight is that the current Or-opt implementation has complex index handling that may produce incorrect moves. A simpler relocation move (moving one city at a time) is more reliable and often just as effective.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def or_opt_pass(tour):
        """Or-opt: try moving segments of 1-3 cities to other positions."""
        improved = False
        for seg_len in [1, 2, 3]:
            if seg_len > n - 2:
                continue
            for i in range(n):
                if time.perf_counter() >= deadline:
                    return tour, improved

                # Segment from i to i+seg_len-1
                i_end = (i + seg_len - 1) % n
                prev_i = (i - 1) % n
                next_end = (i_end + 1) % n

                # Current cost of segment edges
                seg_start = tour[i]
                seg_end = tour[i_end]
                before_seg = tour[prev_i]
                after_seg = tour[next_end]

                old_cost = dist[before_seg, seg_start] + dist[seg_end, after_seg]
                reconnect_cost = dist[before_seg, after_seg]

                # Try inserting segment at different positions
                for j in range(n):
                    if time.perf_counter() >= deadline:
                        return tour, improved

                    # Skip positions that overlap with current segment
                    skip = False
                    for k in range(seg_len + 1):
                        if j == (i + k) % n or j == (i - 1) % n:
                            skip = True
                            break
                    if skip:
                        continue

                    j_next = (j + 1) % n
                    city_j = tour[j]
                    city_j_next = tour[j_next]

                    # Cost of inserting segment between j and j+1
                    new_insert_cost = dist[city_j, seg_start] + dist[seg_end, city_j_next]
                    old_edge_cost = dist[city_j, city_j_next]

                    delta = (reconnect_cost + new_insert_cost) - (old_cost + old_edge_cost)

                    if delta < -0.5:
                        # Perform the move
                        tour_list = tour.tolist()

                        # Extract segment
                        if i <= i_end:
                            segment = tour_list[i:i_end+1]
                            remaining = tour_list[:i] + tour_list[i_end+1:]
                        else:
                            segment = tour_list[i:] + tour_list[:i_end+1]
                            remaining = tour_list[i_end+1:i]

                        # Find new position of j in remaining
                        try:
                            new_j = remaining.index(city_j)
                        except ValueError:
                            continue

                        # Insert segment after new_j
                        new_tour = remaining[:new_j+1] + segment + remaining[new_j+1:]

                        if len(new_tour) == n and len(set(new_tour)) == n:
                            tour = np.array(new_tour, dtype=int)
                            improved = True
                            break
                if improved:
                    break
            if improved:
                break
        return tour, improved
=======
    def relocate_pass(tour):
        """Relocate: try moving single cities to better positions."""
        improved = False
        for i in range(n):
            if time.perf_counter() >= deadline:
                return tour, improved

            # City to relocate
            prev_i = (i - 1) % n
            next_i = (i + 1) % n

            city = tour[i]
            city_prev = tour[prev_i]
            city_next = tour[next_i]

            # Cost of removing city from current position
            removal_gain = (dist[city_prev, city] + dist[city, city_next]
                           - dist[city_prev, city_next])

            # Try inserting between other edges
            best_delta = 0
            best_j = -1

            for j in range(n):
                if j == prev_i or j == i:
                    continue

                j_next = (j + 1) % n
                if j_next == i:
                    continue

                city_j = tour[j]
                city_j_next = tour[j_next]

                # Cost of inserting city between j and j+1
                insertion_cost = (dist[city_j, city] + dist[city, city_j_next]
                                 - dist[city_j, city_j_next])

                delta = insertion_cost - removal_gain

                if delta < best_delta - 0.5:
                    best_delta = delta
                    best_j = j

            if best_j >= 0:
                # Perform the move
                tour_list = tour.tolist()
                city = tour_list.pop(i)

                # Adjust insertion index if needed
                insert_pos = best_j + 1 if best_j < i else best_j
                tour_list.insert(insert_pos, city)

                tour = np.array(tour_list, dtype=int)
                improved = True

        return tour, improved

    def three_opt_segment(tour):
        """Limited 3-opt: try double-bridge moves for diversification."""
        if n < 8:
            return tour, False

        best_tour = tour.copy()
        best_length = calc_tour_length(tour)
        improved = False

        # Try a few random double-bridge moves
        for _ in range(min(20, n)):
            if time.perf_counter() >= deadline:
                break

            # Select 4 random positions
            positions = sorted(np.random.choice(n, 4, replace=False))
            p1, p2, p3, p4 = positions

            # Double bridge: reconnect segments differently
            new_tour = np.concatenate([
                tour[:p1+1],
                tour[p3+1:p4+1],
                tour[p2+1:p3+1],
                tour[p1+1:p2+1],
                tour[p4+1:]
            ])

            if len(new_tour) == n:
                new_length = calc_tour_length(new_tour)
                if new_length < best_length - 0.5:
                    best_tour = new_tour
                    best_length = new_length
                    improved = True

        return best_tour, improved
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Phase 2: Alternating 2-opt and Or-opt improvement
    overall_improved = True
    while overall_improved and time.perf_counter() < deadline:
        overall_improved = False

        # 2-opt until no improvement
        two_opt_improved = True
        while two_opt_improved and time.perf_counter() < deadline:
            tour, two_opt_improved = two_opt_pass(tour)
            if two_opt_improved:
                overall_improved = True

        # Or-opt until no improvement
        if time.perf_counter() < deadline:
            tour, or_opt_improved = or_opt_pass(tour)
            if or_opt_improved:
                overall_improved = True
=======
    # Phase 2: Alternating 2-opt, relocate, and occasional 3-opt
    overall_improved = True
    iteration = 0
    while overall_improved and time.perf_counter() < deadline:
        overall_improved = False
        iteration += 1

        # 2-opt until no improvement
        two_opt_improved = True
        while two_opt_improved and time.perf_counter() < deadline:
            tour, two_opt_improved = two_opt_pass(tour)
            if two_opt_improved:
                overall_improved = True

        # Relocate pass
        if time.perf_counter() < deadline:
            tour, relocate_improved = relocate_pass(tour)
            if relocate_improved:
                overall_improved = True

        # Occasional 3-opt/double-bridge for diversification
        if iteration % 3 == 0 and time.perf_counter() < deadline:
            tour, three_opt_improved = three_opt_segment(tour)
            if three_opt_improved:
                overall_improved = True
>>>>>>> REPLACE
</DIFF>