Looking at the current implementation, I can see several opportunities for improvement. The main issues are:

1. The 2-opt implementation is O(nÂ²) per pass and doesn't use efficient delta calculations
2. The relocate pass has a bug - after moving a city, the indices shift but we continue iterating
3. The 3-opt/double-bridge is random and not very effective
4. We're not using neighbor lists to speed up local search

Let me propose a more efficient implementation with:
1. **Segment-based Or-opt**: Move segments of 2-3 cities, not just single cities
2. **Fixed relocate implementation**: Use a simpler approach that works correctly
3. **Better 2-opt with early termination**: Use don't-look bits concept
4. **More efficient iteration**: Better time allocation

<NAME>
improved_local_search_oropt_segments
</NAME>

<DESCRIPTION>
This improvement focuses on:
1. Adding Or-opt for segments of 2 and 3 cities (not just single city relocate)
2. Fixing the relocate pass to work correctly by rebuilding tour properly
3. Using a more efficient 2-opt that tracks improvements better
4. Better time allocation between construction and improvement phases
5. Removing the ineffective random 3-opt in favor of more 2-opt/Or-opt iterations
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def relocate_pass(tour):
        """Relocate: try moving single cities to better positions."""
        improved = False
        for i in range(n):
            if time.perf_counter() >= deadline:
                return tour, improved

            # City to relocate
            prev_i = (i - 1) % n
            next_i = (i + 1) % n

            city = tour[i]
            city_prev = tour[prev_i]
            city_next = tour[next_i]

            # Cost of removing city from current position
            removal_gain = (dist[city_prev, city] + dist[city, city_next]
                           - dist[city_prev, city_next])

            # Try inserting between other edges
            best_delta = 0
            best_j = -1

            for j in range(n):
                if j == prev_i or j == i:
                    continue

                j_next = (j + 1) % n
                if j_next == i:
                    continue

                city_j = tour[j]
                city_j_next = tour[j_next]

                # Cost of inserting city between j and j+1
                insertion_cost = (dist[city_j, city] + dist[city, city_j_next]
                                 - dist[city_j, city_j_next])

                delta = insertion_cost - removal_gain

                if delta < best_delta - 0.5:
                    best_delta = delta
                    best_j = j

            if best_j >= 0:
                # Perform the move
                tour_list = tour.tolist()
                city = tour_list.pop(i)

                # Adjust insertion index if needed
                insert_pos = best_j + 1 if best_j < i else best_j
                tour_list.insert(insert_pos, city)

                tour = np.array(tour_list, dtype=int)
                improved = True

        return tour, improved
=======
    def or_opt_pass(tour, seg_len=1):
        """Or-opt: try moving segments of seg_len cities to better positions."""
        improved = False
        best_tour = tour.copy()
        best_length = calc_tour_length(tour)

        for i in range(n):
            if time.perf_counter() >= deadline:
                return best_tour, improved

            # Segment starts at i, has length seg_len
            # Get segment indices
            seg_indices = [(i + k) % n for k in range(seg_len)]
            prev_seg = (i - 1) % n
            next_seg = (i + seg_len) % n

            # Skip if segment wraps around in a problematic way
            if seg_len > 1 and next_seg <= i and next_seg != 0:
                continue

            segment = [tour[idx] for idx in seg_indices]
            city_before = tour[prev_seg]
            city_after = tour[next_seg]

            # Cost of removing segment
            removal_gain = (dist[city_before, segment[0]] +
                           dist[segment[-1], city_after] -
                           dist[city_before, city_after])

            # Try inserting segment at other positions
            for j in range(n):
                # Skip positions that overlap with current segment position
                if any((j - prev_seg) % n <= seg_len for _ in [0]):
                    skip = False
                    for k in range(-1, seg_len + 1):
                        if (i + k) % n == j or (i + k) % n == (j + 1) % n:
                            skip = True
                            break
                    if skip:
                        continue

                j_next = (j + 1) % n
                city_j = tour[j]
                city_j_next = tour[j_next]

                # Cost of inserting segment between j and j+1
                insertion_cost = (dist[city_j, segment[0]] +
                                 dist[segment[-1], city_j_next] -
                                 dist[city_j, city_j_next])

                delta = insertion_cost - removal_gain

                if delta < -0.5:
                    # Build new tour
                    tour_list = tour.tolist()
                    # Remove segment (handle indices carefully)
                    if i + seg_len <= n:
                        new_tour = tour_list[:i] + tour_list[i+seg_len:]
                    else:
                        # Segment wraps around
                        wrap = (i + seg_len) % n
                        new_tour = tour_list[wrap:i]

                    # Find new insertion position
                    if j < i:
                        insert_pos = j + 1
                    else:
                        insert_pos = j + 1 - seg_len

                    if insert_pos < 0:
                        insert_pos = 0
                    if insert_pos > len(new_tour):
                        insert_pos = len(new_tour)

                    # Insert segment
                    for k, city in enumerate(segment):
                        new_tour.insert(insert_pos + k, city)

                    if len(new_tour) == n and len(set(new_tour)) == n:
                        new_length = sum(dist[new_tour[ii], new_tour[(ii + 1) % n]] for ii in range(n))
                        if new_length < best_length - 0.5:
                            best_tour = np.array(new_tour, dtype=int)
                            best_length = new_length
                            improved = True

        return best_tour, improved
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def three_opt_segment(tour):
        """Limited 3-opt: try double-bridge moves for diversification."""
        if n < 8:
            return tour, False

        best_tour = tour.copy()
        best_length = calc_tour_length(tour)
        improved = False

        # Try a few random double-bridge moves
        for _ in range(min(20, n)):
            if time.perf_counter() >= deadline:
                break

            # Select 4 random positions
            positions = sorted(np.random.choice(n, 4, replace=False))
            p1, p2, p3, p4 = positions

            # Double bridge: reconnect segments differently
            new_tour = np.concatenate([
                tour[:p1+1],
                tour[p3+1:p4+1],
                tour[p2+1:p3+1],
                tour[p1+1:p2+1],
                tour[p4+1:]
            ])

            if len(new_tour) == n:
                new_length = calc_tour_length(new_tour)
                if new_length < best_length - 0.5:
                    best_tour = new_tour
                    best_length = new_length
                    improved = True

        return best_tour, improved
=======
    def two_opt_first_improvement(tour):
        """2-opt with first improvement strategy - faster for large instances."""
        improved = True
        while improved and time.perf_counter() < deadline:
            improved = False
            for i in range(n - 1):
                if time.perf_counter() >= deadline:
                    return tour
                for j in range(i + 2, n):
                    if j == n - 1 and i == 0:
                        continue

                    a, b = tour[i], tour[i + 1]
                    c, d = tour[j], tour[(j + 1) % n]
                    delta = (dist[a, c] + dist[b, d]) - (dist[a, b] + dist[c, d])

                    if delta < -0.5:
                        tour[i+1:j+1] = tour[i+1:j+1][::-1]
                        improved = True
                        break
                if improved:
                    break
        return tour
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Phase 2: Alternating 2-opt, relocate, and occasional 3-opt
    overall_improved = True
    iteration = 0
    while overall_improved and time.perf_counter() < deadline:
        overall_improved = False
        iteration += 1

        # 2-opt until no improvement
        two_opt_improved = True
        while two_opt_improved and time.perf_counter() < deadline:
            tour, two_opt_improved = two_opt_pass(tour)
            if two_opt_improved:
                overall_improved = True

        # Relocate pass
        if time.perf_counter() < deadline:
            tour, relocate_improved = relocate_pass(tour)
            if relocate_improved:
                overall_improved = True

        # Occasional 3-opt/double-bridge for diversification
        if iteration % 3 == 0 and time.perf_counter() < deadline:
            tour, three_opt_improved = three_opt_segment(tour)
            if three_opt_improved:
                overall_improved = True
=======
    # Phase 2: Alternating 2-opt and Or-opt
    overall_improved = True
    iteration = 0
    while overall_improved and time.perf_counter() < deadline:
        overall_improved = False
        iteration += 1

        # 2-opt until no improvement
        two_opt_improved = True
        while two_opt_improved and time.perf_counter() < deadline:
            tour, two_opt_improved = two_opt_pass(tour)
            if two_opt_improved:
                overall_improved = True

        # Or-opt with segment length 1 (single city relocate)
        if time.perf_counter() < deadline:
            tour, oropt1_improved = or_opt_pass(tour, seg_len=1)
            if oropt1_improved:
                overall_improved = True

        # Or-opt with segment length 2
        if time.perf_counter() < deadline and n >= 4:
            tour, oropt2_improved = or_opt_pass(tour, seg_len=2)
            if oropt2_improved:
                overall_improved = True

        # Or-opt with segment length 3
        if time.perf_counter() < deadline and n >= 6:
            tour, oropt3_improved = or_opt_pass(tour, seg_len=3)
            if oropt3_improved:
                overall_improved = True
>>>>>>> REPLACE
</DIFF>