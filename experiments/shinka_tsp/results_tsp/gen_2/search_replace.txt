Looking at the current implementation, I can see it's using a Christofides-inspired approach with 3-opt local search. The performance is already quite good, but there are several areas for improvement. Let me propose a targeted enhancement that should improve the solution quality.

<NAME>
or_opt_enhancement
</NAME>

<DESCRIPTION>
The current 3-opt implementation has some issues and limitations. I'm proposing to replace it with a more efficient Or-opt local search that relocates sequences of 1, 2, or 3 consecutive cities to different positions in the tour. Or-opt is often more effective than 3-opt for TSP because:

1. It's computationally simpler and faster than full 3-opt
2. It can make more diverse moves by relocating city sequences
3. It's less prone to getting stuck in local optima
4. The current 3-opt implementation has bugs in the move calculations

This change should improve both solution quality and allow more iterations within the time limit.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def three_opt_improvement(tour, dist, n, deadline):
    """3-opt local search improvement."""
    tour = tour[:]
    improved = True

    while improved and time.perf_counter() < deadline:
        improved = False

        for i in range(n - 2):
            if time.perf_counter() >= deadline:
                break

            for j in range(i + 2, n - 1):
                if time.perf_counter() >= deadline:
                    break

                for k in range(j + 2, n):
                    if k == i:
                        continue

                    # Current edges: (i,i+1), (j,j+1), (k,k+1)
                    a, b = tour[i], tour[i + 1]
                    c, d = tour[j], tour[j + 1]
                    e, f = tour[k], tour[(k + 1) % n]

                    current_cost = dist[a, b] + dist[c, d] + dist[e, f]

                    # Try different 3-opt moves
                    moves = [
                        # Move 1: reverse segment (i+1, j)
                        (dist[a, c] + dist[b, d] + dist[e, f], 1),
                        # Move 2: reverse segment (j+1, k)
                        (dist[a, b] + dist[c, e] + dist[d, f], 2),
                        # Move 3: reverse both segments
                        (dist[a, c] + dist[b, e] + dist[d, f], 3),
                        # Move 4: relocate segment (i+1, j) after k
                        (dist[a, d] + dist[c, f] + dist[e, b], 4),
                        # Move 5: relocate segment (j+1, k) after i
                        (dist[a, d] + dist[c, b] + dist[e, f], 5)
                    ]

                    best_cost, best_move = min(moves)

                    if best_cost < current_cost - 1e-9:
                        # Apply the best move
                        if best_move == 1:
                            tour[i+1:j+1] = tour[i+1:j+1][::-1]
                        elif best_move == 2:
                            tour[j+1:k+1] = tour[j+1:k+1][::-1]
                        elif best_move == 3:
                            tour[i+1:j+1] = tour[i+1:j+1][::-1]
                            tour[j+1:k+1] = tour[j+1:k+1][::-1]
                        elif best_move == 4:
                            # Relocate (i+1, j) after k
                            segment = tour[i+1:j+1]
                            tour = tour[:i+1] + tour[j+1:k+1] + segment + tour[k+1:]
                        elif best_move == 5:
                            # Relocate (j+1, k) after i
                            segment = tour[j+1:k+1]
                            tour = tour[:i+1] + segment + tour[i+1:j+1] + tour[k+1:]

                        improved = True
                        break

                if improved:
                    break
            if improved:
                break

    return tour
=======
def or_opt_improvement(tour, dist, n, deadline):
    """Or-opt local search improvement - relocate sequences of 1-3 cities."""
    tour = tour[:]
    improved = True

    while improved and time.perf_counter() < deadline:
        improved = False

        # Try relocating sequences of length 1, 2, and 3
        for seq_len in [1, 2, 3]:
            if improved or time.perf_counter() >= deadline:
                break

            for i in range(n):
                if time.perf_counter() >= deadline:
                    break

                # Don't try sequences that would wrap around or be too long
                if i + seq_len > n:
                    continue

                # Try inserting the sequence at each possible position
                for j in range(n):
                    if j >= i and j < i + seq_len:
                        continue  # Skip positions within the sequence

                    # Calculate improvement for moving sequence starting at i to position j
                    delta = calculate_or_opt_delta(tour, dist, n, i, seq_len, j)

                    if delta < -1e-9:
                        # Apply the move
                        apply_or_opt_move(tour, i, seq_len, j)
                        improved = True
                        break

                if improved:
                    break

    return tour


def calculate_or_opt_delta(tour, dist, n, start, seq_len, insert_pos):
    """Calculate the change in tour length for an Or-opt move."""
    # Positions in the tour
    prev_start = (start - 1) % n
    end = (start + seq_len - 1) % n
    next_end = (end + 1) % n

    # Current cost: edges around the sequence
    current_cost = dist[tour[prev_start], tour[start]] + dist[tour[end], tour[next_end]]

    # Cost after removing sequence
    removal_cost = dist[tour[prev_start], tour[next_end]]

    # Calculate insertion cost
    if insert_pos < start:
        # Insert before the original position
        prev_insert = (insert_pos - 1) % n
        insertion_cost = (dist[tour[prev_insert], tour[start]] +
                         dist[tour[end], tour[insert_pos]])
        new_cost = current_cost - removal_cost + insertion_cost
    else:
        # Insert after the original position (adjust for removal)
        actual_insert = insert_pos - seq_len
        if actual_insert < 0:
            actual_insert = 0
        prev_insert = (actual_insert - 1) % n
        next_insert = actual_insert % n
        insertion_cost = (dist[tour[prev_insert], tour[start]] +
                         dist[tour[end], tour[next_insert]])
        new_cost = current_cost - removal_cost + insertion_cost

    return new_cost - current_cost


def apply_or_opt_move(tour, start, seq_len, insert_pos):
    """Apply an Or-opt move to the tour."""
    n = len(tour)
    sequence = tour[start:start + seq_len]

    if insert_pos < start:
        # Insert before original position
        new_tour = (tour[:insert_pos] + sequence +
                   tour[insert_pos:start] + tour[start + seq_len:])
    else:
        # Insert after original position
        actual_insert = insert_pos - seq_len
        new_tour = (tour[:start] + tour[start + seq_len:actual_insert] +
                   sequence + tour[actual_insert:])

    tour[:] = new_tour
=======
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Phase 2: 3-opt improvement
        tour = three_opt_improvement(tour, dist, n, start_deadline)
=======
        # Phase 2: Or-opt improvement
        tour = or_opt_improvement(tour, dist, n, start_deadline)
>>>>>>> REPLACE
</DIFF>