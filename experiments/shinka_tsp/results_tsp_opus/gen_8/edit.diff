--- a/original.py
+++ b/original.py
@@ -1,308 +1,320 @@
 # EVOLVE-BLOCK-START
 """
 TSP Solver: Multi-start with neighbor-list 2-opt + Or-opt + ILS
 
 Uses neighbor lists for efficient 2-opt and iterated local search for diversification.
 """
 
 import numpy as np
 import time
 import random
 
 
 def solve_tsp(coords: np.ndarray, time_limit_ms: int = 5000) -> tuple:
     """
     Solve TSP instance.
 
     Args:
         coords: np.ndarray of shape (n, 2) with city coordinates
         time_limit_ms: Wall-clock time limit in milliseconds
 
     Returns:
         Tuple of (tour, length) where tour is list of city indices
     """
     n = len(coords)
 
     if n <= 1:
         return list(range(n)), 0.0
 
     if n == 2:
         return [0, 1], round(np.sqrt(np.sum((coords[0] - coords[1]) ** 2)))
 
     # Vectorized distance matrix computation
     diff = coords[:, np.newaxis, :] - coords[np.newaxis, :, :]
     dist = np.round(np.sqrt(np.sum(diff ** 2, axis=2)))
 
     start_time = time.perf_counter()
     deadline = start_time + time_limit_ms / 1000.0
 
     # Build neighbor lists (k nearest neighbors for each city)
-    k_neighbors = min(20, n - 1)
+    k_neighbors = min(30, n - 1)  # Increased from 20 to 30 for better coverage
     neighbors = np.zeros((n, k_neighbors), dtype=np.int32)
     for i in range(n):
         sorted_idx = np.argsort(dist[i])
         neighbors[i] = sorted_idx[1:k_neighbors+1]  # Exclude self
 
     def calc_tour_length(tour):
         total = 0
         for i in range(n):
             total += dist[tour[i], tour[(i + 1) % n]]
         return total
 
     def nearest_neighbor_fast(start_city):
         """Optimized nearest neighbor construction."""
         tour = [start_city]
         visited = set([start_city])
         current = start_city
 
         for _ in range(n - 1):
             best_dist = np.inf
             best_next = -1
             for j in range(n):
                 if j not in visited and dist[current, j] < best_dist:
                     best_dist = dist[current, j]
                     best_next = j
             tour.append(best_next)
             visited.add(best_next)
             current = best_next
 
         return tour
 
     def two_opt_full(tour, deadline):
-        """Full 2-opt with position tracking."""
+        """Full 2-opt with position tracking, checking neighbors of both endpoints."""
         tour = list(tour)
         # Position array: pos[city] = position in tour
         pos = [0] * n
         for i in range(n):
             pos[tour[i]] = i
 
         improved = True
         while improved and time.perf_counter() < deadline:
             improved = False
             for i in range(n):
                 if time.perf_counter() >= deadline:
                     break
 
                 city_i = tour[i]
                 city_i1 = tour[(i + 1) % n]
 
-                # Check neighbors of city_i for potential 2-opt moves
+                # Check neighbors of both city_i and city_i1 for potential 2-opt moves
+                candidates = set()
                 for city_c in neighbors[city_i]:
+                    candidates.add(city_c)
+                for city_c in neighbors[city_i1]:
+                    candidates.add(city_c)
+
+                for city_c in candidates:
                     j = pos[city_c]
 
                     # Ensure i < j for proper segment reversal
                     if j <= i + 1 or (i == 0 and j == n - 1):
                         continue
 
                     city_d = tour[(j + 1) % n]
 
                     # Delta for reversing segment [i+1, j]
                     delta = (dist[city_i, city_c] + dist[city_i1, city_d]) - \
                             (dist[city_i, city_i1] + dist[city_c, city_d])
 
                     if delta < -0.5:
                         # Reverse segment [i+1, j]
                         left, right = i + 1, j
                         while left < right:
                             tour[left], tour[right] = tour[right], tour[left]
                             pos[tour[left]] = left
                             pos[tour[right]] = right
                             left += 1
                             right -= 1
                         if left == right:
                             pos[tour[left]] = left
                         improved = True
                         break
+                if improved:
+                    break
 
         return tour
 
     def or_opt_pass(tour, deadline):
         """Or-opt: relocate segments of 1, 2, or 3 consecutive cities."""
         tour = list(tour)
         improved = True
 
         while improved and time.perf_counter() < deadline:
             improved = False
 
             for seg_len in [1, 2, 3]:
                 if improved or time.perf_counter() >= deadline:
                     break
 
-                for i in range(n):
+                for i in range(n - seg_len + 1):
                     if time.perf_counter() >= deadline:
                         break
 
-                    # Skip if segment wraps around
-                    if i + seg_len > n:
-                        continue
-
                     prev_i = (i - 1 + n) % n
-                    next_seg = (i + seg_len) % n
+                    next_seg = i + seg_len
 
                     seg_start_city = tour[i]
                     seg_end_city = tour[i + seg_len - 1]
                     prev_city = tour[prev_i]
+
+                    # Handle wrap-around for next_city
+                    if next_seg >= n:
+                        continue
                     next_city = tour[next_seg]
 
                     # Cost of current configuration
                     current_cost = dist[prev_city, seg_start_city] + dist[seg_end_city, next_city]
                     reconnect_cost = dist[prev_city, next_city]
 
                     best_delta = 0
                     best_j = -1
 
                     # Try inserting after position j
-                    for j in range(n - seg_len):
+                    for j in range(n - 1):
                         # Skip if j is in or adjacent to current segment position
-                        if j >= prev_i - 1 and j <= i + seg_len:
+                        if j >= i - 1 and j < i + seg_len:
                             continue
 
                         city_j = tour[j]
-                        city_j1 = tour[j + 1]
+                        city_j1 = tour[(j + 1) % n]
 
                         # Cost of inserting segment between j and j+1
                         insert_cost = dist[city_j, seg_start_city] + dist[seg_end_city, city_j1]
                         edge_cost = dist[city_j, city_j1]
 
                         delta = reconnect_cost + insert_cost - current_cost - edge_cost
 
                         if delta < best_delta - 0.5:
                             best_delta = delta
                             best_j = j
 
                     if best_j != -1:
                         segment = tour[i:i+seg_len]
                         new_tour = tour[:i] + tour[i+seg_len:]
                         if best_j < i:
                             insert_pos = best_j + 1
                         else:
                             insert_pos = best_j + 1 - seg_len
                         tour = new_tour[:insert_pos] + segment + new_tour[insert_pos:]
                         improved = True
                         break
 
         return tour
 
     def perturb_tour(tour):
         """Double-bridge perturbation for escaping local minima."""
         tour = list(tour)
         if n < 8:
             # Simple swap for small instances
             i, j = random.sample(range(n), 2)
             tour[i], tour[j] = tour[j], tour[i]
             return tour
 
         # Select 4 random positions ensuring proper spacing
         positions = sorted(random.sample(range(n), 4))
         p1, p2, p3, p4 = positions
 
         # Double-bridge move
         new_tour = (tour[:p1+1] + tour[p3+1:p4+1] +
                    tour[p2+1:p3+1] + tour[p1+1:p2+1] + tour[p4+1:])
 
         return new_tour
 
-    # Phase 1: Multi-start construction (10% of time)
-    construction_deadline = start_time + (time_limit_ms / 1000.0) * 0.10
-
-    num_starts = min(n, 15)
+    # Phase 1: Multi-start construction (8% of time)
+    construction_deadline = start_time + (time_limit_ms / 1000.0) * 0.08
+
+    num_starts = min(n, 20)  # Try more starting points
     if n <= 20:
         start_cities = list(range(n))
     else:
         start_cities = [int(i * n / num_starts) for i in range(num_starts)]
 
     best_tour = None
     best_length = np.inf
 
     for start in start_cities:
         if time.perf_counter() >= construction_deadline:
             break
         tour = nearest_neighbor_fast(start)
         length = calc_tour_length(tour)
         if length < best_length:
             best_length = length
             best_tour = tour[:]
 
     if best_tour is None:
         best_tour = nearest_neighbor_fast(0)
 
     # Phase 2: Intensive local search on best construction
     tour = best_tour[:]
 
     # Initial full optimization
     mini_deadline = min(deadline, time.perf_counter() + (deadline - time.perf_counter()) * 0.5)
     tour = two_opt_full(tour, mini_deadline)
 
     if time.perf_counter() < deadline:
         mini_deadline = min(deadline, time.perf_counter() + (deadline - time.perf_counter()) * 0.3)
         tour = or_opt_pass(tour, mini_deadline)
 
     best_overall_tour = tour[:]
     best_overall_length = calc_tour_length(tour)
 
-    # Phase 3: Iterated Local Search
+    # Phase 3: Iterated Local Search with adaptive perturbation
     no_improve_count = 0
-    while time.perf_counter() < deadline - 0.05:
-        # Perturb
-        perturbed = perturb_tour(best_overall_tour)
+    perturbation_strength = 1
+    while time.perf_counter() < deadline - 0.03:
+        # Perturb with adaptive strength
+        perturbed = best_overall_tour[:]
+        for _ in range(perturbation_strength):
+            perturbed = perturb_tour(perturbed)
 
         # Local search on perturbed
         remaining = deadline - time.perf_counter()
-        mini_deadline = time.perf_counter() + min(remaining * 0.3, 0.2)
+        mini_deadline = time.perf_counter() + min(remaining * 0.35, 0.15)
         perturbed = two_opt_full(perturbed, mini_deadline)
 
         if time.perf_counter() < deadline - 0.02:
-            mini_deadline = time.perf_counter() + min(remaining * 0.15, 0.1)
+            mini_deadline = time.perf_counter() + min(remaining * 0.2, 0.08)
             perturbed = or_opt_pass(perturbed, mini_deadline)
 
         perturbed_length = calc_tour_length(perturbed)
 
         if perturbed_length < best_overall_length:
             best_overall_length = perturbed_length
             best_overall_tour = perturbed[:]
             no_improve_count = 0
+            perturbation_strength = 1
         else:
             no_improve_count += 1
 
-        # If stuck, do more aggressive perturbation
-        if no_improve_count > 5:
-            tour = best_overall_tour[:]
+        # Increase perturbation strength if stuck
+        if no_improve_count > 3:
+            perturbation_strength = min(perturbation_strength + 1, 3)
             no_improve_count = 0
 
     return best_overall_tour, best_overall_length
 
 
 # EVOLVE-BLOCK-END
 
 
 def run_experiment(coords: np.ndarray, time_limit_ms: int = 5000, optimal_length: float = None) -> dict:
     """
     Entry point for ShinkaEvolve evaluation.
 
     Args:
         coords: np.ndarray of shape (n, 2) with city coordinates
         time_limit_ms: Wall-clock time limit in milliseconds
         optimal_length: Known optimal tour length (if available)
 
     Returns:
         dict with tour, length, valid, and score
     """
     tour, length = solve_tsp(coords, time_limit_ms)
 
     # Validate tour
     n = len(coords)
     valid = (len(tour) == n and set(tour) == set(range(n)))
 
     # Score: ratio of optimal to found (higher is better, max 1.0)
     if optimal_length and optimal_length > 0:
         score = optimal_length / length if length > 0 else 0.0
     else:
         # If no optimal, use inverse of length (normalized)
         score = 1000.0 / length if length > 0 else 0.0
 
     return {
         'tour': tour,
         'length': length,
         'valid': valid,
         'score': score
     }