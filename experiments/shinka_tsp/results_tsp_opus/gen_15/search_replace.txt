Looking at the performance metrics, I notice that the current implementation scores around 0.19, which is similar to other variants. The key bottleneck seems to be that the Or-opt pass is doing a full scan of all positions for each segment, which is slow. Let me propose an optimization that uses neighbor lists for Or-opt as well, making it more efficient and allowing more iterations.

Additionally, I'll add a smarter candidate selection for 2-opt that prioritizes the most promising moves by sorting candidates by potential improvement.

<NAME>
neighbor_list_or_opt_with_position_tracking
</NAME>

<DESCRIPTION>
This change improves the Or-opt pass by:
1. Using neighbor lists to find promising insertion points instead of scanning all positions
2. Maintaining a position array for faster lookups
3. This makes Or-opt much faster, allowing more ILS iterations within the time limit

The key insight is that good insertion points for a segment are likely to be near the neighbors of the segment's endpoints. By only checking these candidates, we can run Or-opt much faster while still finding most improvements.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def or_opt_pass(tour, deadline):
        """Or-opt: relocate segments of 1, 2, or 3 consecutive cities."""
        tour = list(tour)
        improved = True

        while improved and time.perf_counter() < deadline:
            improved = False

            for seg_len in [1, 2, 3]:
                if improved or time.perf_counter() >= deadline:
                    break

                for i in range(n - seg_len + 1):
                    if time.perf_counter() >= deadline:
                        break

                    prev_i = (i - 1 + n) % n
                    next_seg = i + seg_len

                    seg_start_city = tour[i]
                    seg_end_city = tour[i + seg_len - 1]
                    prev_city = tour[prev_i]

                    # Handle wrap-around for next_city
                    if next_seg >= n:
                        continue
                    next_city = tour[next_seg]

                    # Cost of current configuration
                    current_cost = dist[prev_city, seg_start_city] + dist[seg_end_city, next_city]
                    reconnect_cost = dist[prev_city, next_city]

                    best_delta = 0
                    best_j = -1

                    # Try inserting after position j
                    for j in range(n - 1):
                        # Skip if j is in or adjacent to current segment position
                        if j >= i - 1 and j < i + seg_len:
                            continue

                        city_j = tour[j]
                        city_j1 = tour[(j + 1) % n]

                        # Cost of inserting segment between j and j+1
                        insert_cost = dist[city_j, seg_start_city] + dist[seg_end_city, city_j1]
                        edge_cost = dist[city_j, city_j1]

                        delta = reconnect_cost + insert_cost - current_cost - edge_cost

                        if delta < best_delta - 0.5:
                            best_delta = delta
                            best_j = j

                    if best_j != -1:
                        segment = tour[i:i+seg_len]
                        new_tour = tour[:i] + tour[i+seg_len:]
                        if best_j < i:
                            insert_pos = best_j + 1
                        else:
                            insert_pos = best_j + 1 - seg_len
                        tour = new_tour[:insert_pos] + segment + new_tour[insert_pos:]
                        improved = True
                        break

        return tour
=======
    def or_opt_pass(tour, deadline):
        """Or-opt: relocate segments of 1, 2, or 3 consecutive cities using neighbor lists."""
        tour = list(tour)
        pos = [0] * n
        for idx in range(n):
            pos[tour[idx]] = idx

        improved = True

        while improved and time.perf_counter() < deadline:
            improved = False

            for seg_len in [1, 2, 3]:
                if improved or time.perf_counter() >= deadline:
                    break

                for i in range(n - seg_len + 1):
                    if time.perf_counter() >= deadline:
                        break

                    prev_i = (i - 1 + n) % n
                    next_seg = i + seg_len

                    if next_seg >= n:
                        continue

                    seg_start_city = tour[i]
                    seg_end_city = tour[i + seg_len - 1]
                    prev_city = tour[prev_i]
                    next_city = tour[next_seg]

                    # Cost of current configuration
                    current_cost = dist[prev_city, seg_start_city] + dist[seg_end_city, next_city]
                    reconnect_cost = dist[prev_city, next_city]

                    best_delta = 0
                    best_j = -1

                    # Use neighbor lists to find promising insertion points
                    candidate_cities = set()
                    for nc in neighbors[seg_start_city]:
                        candidate_cities.add(nc)
                    for nc in neighbors[seg_end_city]:
                        candidate_cities.add(nc)

                    for city_j in candidate_cities:
                        j = pos[city_j]

                        # Skip if j is in or adjacent to current segment position
                        if j >= i - 1 and j <= i + seg_len:
                            continue
                        if j >= n - 1:
                            continue

                        city_j1 = tour[j + 1]

                        # Cost of inserting segment between j and j+1
                        insert_cost = dist[city_j, seg_start_city] + dist[seg_end_city, city_j1]
                        edge_cost = dist[city_j, city_j1]

                        delta = reconnect_cost + insert_cost - current_cost - edge_cost

                        if delta < best_delta - 0.5:
                            best_delta = delta
                            best_j = j

                    if best_j != -1:
                        segment = tour[i:i+seg_len]
                        new_tour = tour[:i] + tour[i+seg_len:]
                        if best_j < i:
                            insert_pos = best_j + 1
                        else:
                            insert_pos = best_j + 1 - seg_len
                        tour = new_tour[:insert_pos] + segment + new_tour[insert_pos:]
                        # Rebuild position array
                        for idx in range(n):
                            pos[tour[idx]] = idx
                        improved = True
                        break

        return tour
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Phase 3: Iterated Local Search with adaptive perturbation
    no_improve_count = 0
    perturbation_strength = 1
    while time.perf_counter() < deadline - 0.03:
        # Perturb with adaptive strength
        perturbed = best_overall_tour[:]
        for _ in range(perturbation_strength):
            perturbed = perturb_tour(perturbed)

        # Local search on perturbed
        remaining = deadline - time.perf_counter()
        mini_deadline = time.perf_counter() + min(remaining * 0.35, 0.15)
        perturbed = two_opt_full(perturbed, mini_deadline)

        if time.perf_counter() < deadline - 0.02:
            mini_deadline = time.perf_counter() + min(remaining * 0.2, 0.08)
            perturbed = or_opt_pass(perturbed, mini_deadline)

        perturbed_length = calc_tour_length(perturbed)

        if perturbed_length < best_overall_length:
            best_overall_length = perturbed_length
            best_overall_tour = perturbed[:]
            no_improve_count = 0
            perturbation_strength = 1
        else:
            no_improve_count += 1

        # Increase perturbation strength if stuck
        if no_improve_count > 3:
            perturbation_strength = min(perturbation_strength + 1, 3)
            no_improve_count = 0
=======
    # Phase 3: Iterated Local Search with adaptive perturbation
    no_improve_count = 0
    perturbation_strength = 1
    iteration = 0
    while time.perf_counter() < deadline - 0.02:
        iteration += 1
        # Perturb with adaptive strength
        perturbed = best_overall_tour[:]
        for _ in range(perturbation_strength):
            perturbed = perturb_tour(perturbed)

        # Local search on perturbed - use shorter time limits for more iterations
        remaining = deadline - time.perf_counter()
        mini_deadline = time.perf_counter() + min(remaining * 0.25, 0.08)
        perturbed = two_opt_full(perturbed, mini_deadline)

        if time.perf_counter() < deadline - 0.015:
            mini_deadline = time.perf_counter() + min(remaining * 0.15, 0.05)
            perturbed = or_opt_pass(perturbed, mini_deadline)

        perturbed_length = calc_tour_length(perturbed)

        if perturbed_length < best_overall_length:
            best_overall_length = perturbed_length
            best_overall_tour = perturbed[:]
            no_improve_count = 0
            perturbation_strength = 1
        else:
            no_improve_count += 1

        # Increase perturbation strength if stuck
        if no_improve_count > 4:
            perturbation_strength = min(perturbation_strength + 1, 4)
            no_improve_count = 0
>>>>>>> REPLACE
</DIFF>