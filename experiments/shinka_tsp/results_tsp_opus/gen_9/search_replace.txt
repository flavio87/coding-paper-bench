Looking at the performance metrics, I notice that the current implementation achieves a combined score of 0.19. The individual scores decrease significantly for larger instances, suggesting the algorithm struggles with scalability.

Let me analyze the key bottlenecks and propose improvements:

1. **The 2-opt implementation only checks neighbors of one endpoint** - it should check neighbors of both endpoints of the edge being considered
2. **The Or-opt is slow** - it checks all positions instead of using neighbor lists
3. **The ILS phase could benefit from better time allocation**

<NAME>
improved_2opt_both_endpoints_and_faster_oropt
</NAME>

<DESCRIPTION>
This improvement makes two key changes:
1. In two_opt_full, check neighbors of BOTH endpoints (city_i and city_i1) of the edge being considered. This doubles the chance of finding improving moves without significantly increasing computation.
2. Use neighbor lists in Or-opt to focus on promising insertion positions rather than checking all positions. This makes Or-opt much faster and allows more iterations.
3. Increase neighbor list size to 25 for better coverage.
4. Adjust time allocation to spend more time in the ILS phase where improvements are found.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Build neighbor lists (k nearest neighbors for each city)
    k_neighbors = min(20, n - 1)
    neighbors = np.zeros((n, k_neighbors), dtype=np.int32)
    for i in range(n):
        sorted_idx = np.argsort(dist[i])
        neighbors[i] = sorted_idx[1:k_neighbors+1]  # Exclude self
=======
    # Build neighbor lists (k nearest neighbors for each city)
    k_neighbors = min(25, n - 1)
    neighbors = np.zeros((n, k_neighbors), dtype=np.int32)
    for i in range(n):
        sorted_idx = np.argsort(dist[i])
        neighbors[i] = sorted_idx[1:k_neighbors+1]  # Exclude self
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def two_opt_full(tour, deadline):
        """Full 2-opt with position tracking."""
        tour = list(tour)
        # Position array: pos[city] = position in tour
        pos = [0] * n
        for i in range(n):
            pos[tour[i]] = i

        improved = True
        while improved and time.perf_counter() < deadline:
            improved = False
            for i in range(n):
                if time.perf_counter() >= deadline:
                    break

                city_i = tour[i]
                city_i1 = tour[(i + 1) % n]

                # Check neighbors of city_i for potential 2-opt moves
                for city_c in neighbors[city_i]:
                    j = pos[city_c]

                    # Ensure i < j for proper segment reversal
                    if j <= i + 1 or (i == 0 and j == n - 1):
                        continue

                    city_d = tour[(j + 1) % n]

                    # Delta for reversing segment [i+1, j]
                    delta = (dist[city_i, city_c] + dist[city_i1, city_d]) - \
                            (dist[city_i, city_i1] + dist[city_c, city_d])

                    if delta < -0.5:
                        # Reverse segment [i+1, j]
                        left, right = i + 1, j
                        while left < right:
                            tour[left], tour[right] = tour[right], tour[left]
                            pos[tour[left]] = left
                            pos[tour[right]] = right
                            left += 1
                            right -= 1
                        if left == right:
                            pos[tour[left]] = left
                        improved = True
                        break

        return tour
=======
    def two_opt_full(tour, deadline):
        """Full 2-opt with position tracking, checking neighbors of both endpoints."""
        tour = list(tour)
        # Position array: pos[city] = position in tour
        pos = [0] * n
        for i in range(n):
            pos[tour[i]] = i

        improved = True
        while improved and time.perf_counter() < deadline:
            improved = False
            for i in range(n):
                if time.perf_counter() >= deadline:
                    break

                city_i = tour[i]
                city_i1 = tour[(i + 1) % n]

                # Check neighbors of both city_i and city_i1 for potential 2-opt moves
                candidates = set()
                for nc in neighbors[city_i]:
                    candidates.add(nc)
                for nc in neighbors[city_i1]:
                    candidates.add(nc)

                for city_c in candidates:
                    j = pos[city_c]

                    # Ensure i < j for proper segment reversal
                    if j <= i + 1 or (i == 0 and j == n - 1):
                        continue

                    city_d = tour[(j + 1) % n]

                    # Delta for reversing segment [i+1, j]
                    delta = (dist[city_i, city_c] + dist[city_i1, city_d]) - \
                            (dist[city_i, city_i1] + dist[city_c, city_d])

                    if delta < -0.5:
                        # Reverse segment [i+1, j]
                        left, right = i + 1, j
                        while left < right:
                            tour[left], tour[right] = tour[right], tour[left]
                            pos[tour[left]] = left
                            pos[tour[right]] = right
                            left += 1
                            right -= 1
                        if left == right:
                            pos[tour[left]] = left
                        improved = True
                        break
                if improved:
                    break

        return tour
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def or_opt_pass(tour, deadline):
        """Or-opt: relocate segments of 1, 2, or 3 consecutive cities."""
        tour = list(tour)
        improved = True

        while improved and time.perf_counter() < deadline:
            improved = False

            for seg_len in [1, 2, 3]:
                if improved or time.perf_counter() >= deadline:
                    break

                for i in range(n):
                    if time.perf_counter() >= deadline:
                        break

                    # Skip if segment wraps around
                    if i + seg_len > n:
                        continue

                    prev_i = (i - 1 + n) % n
                    next_seg = (i + seg_len) % n

                    seg_start_city = tour[i]
                    seg_end_city = tour[i + seg_len - 1]
                    prev_city = tour[prev_i]
                    next_city = tour[next_seg]

                    # Cost of current configuration
                    current_cost = dist[prev_city, seg_start_city] + dist[seg_end_city, next_city]
                    reconnect_cost = dist[prev_city, next_city]

                    best_delta = 0
                    best_j = -1

                    # Try inserting after position j
                    for j in range(n - seg_len):
                        # Skip if j is in or adjacent to current segment position
                        if j >= prev_i - 1 and j <= i + seg_len:
                            continue

                        city_j = tour[j]
                        city_j1 = tour[j + 1]

                        # Cost of inserting segment between j and j+1
                        insert_cost = dist[city_j, seg_start_city] + dist[seg_end_city, city_j1]
                        edge_cost = dist[city_j, city_j1]

                        delta = reconnect_cost + insert_cost - current_cost - edge_cost

                        if delta < best_delta - 0.5:
                            best_delta = delta
                            best_j = j

                    if best_j != -1:
                        segment = tour[i:i+seg_len]
                        new_tour = tour[:i] + tour[i+seg_len:]
                        if best_j < i:
                            insert_pos = best_j + 1
                        else:
                            insert_pos = best_j + 1 - seg_len
                        tour = new_tour[:insert_pos] + segment + new_tour[insert_pos:]
                        improved = True
                        break

        return tour
=======
    def or_opt_pass(tour, deadline):
        """Or-opt: relocate segments of 1, 2, or 3 consecutive cities using neighbor lists."""
        tour = list(tour)
        pos = [0] * n
        for i in range(n):
            pos[tour[i]] = i

        improved = True

        while improved and time.perf_counter() < deadline:
            improved = False

            for seg_len in [1, 2, 3]:
                if improved or time.perf_counter() >= deadline:
                    break

                for i in range(n):
                    if time.perf_counter() >= deadline:
                        break

                    # Skip if segment wraps around
                    if i + seg_len > n:
                        continue

                    prev_i = (i - 1 + n) % n
                    next_seg = i + seg_len
                    if next_seg >= n:
                        continue

                    seg_start_city = tour[i]
                    seg_end_city = tour[i + seg_len - 1]
                    prev_city = tour[prev_i]
                    next_city = tour[next_seg]

                    # Cost of current configuration
                    current_cost = dist[prev_city, seg_start_city] + dist[seg_end_city, next_city]
                    reconnect_cost = dist[prev_city, next_city]

                    best_delta = 0
                    best_j = -1

                    # Use neighbor lists to find promising insertion points
                    # Check neighbors of segment start and end cities
                    candidate_cities = set()
                    for nc in neighbors[seg_start_city]:
                        candidate_cities.add(nc)
                    for nc in neighbors[seg_end_city]:
                        candidate_cities.add(nc)

                    for city_j in candidate_cities:
                        j = pos[city_j]

                        # Skip if j is in or adjacent to current segment position
                        if j >= i - 1 and j <= i + seg_len:
                            continue
                        if j >= n - 1:
                            continue

                        city_j1 = tour[j + 1]

                        # Cost of inserting segment between j and j+1
                        insert_cost = dist[city_j, seg_start_city] + dist[seg_end_city, city_j1]
                        edge_cost = dist[city_j, city_j1]

                        delta = reconnect_cost + insert_cost - current_cost - edge_cost

                        if delta < best_delta - 0.5:
                            best_delta = delta
                            best_j = j

                    if best_j != -1:
                        segment = tour[i:i+seg_len]
                        new_tour = tour[:i] + tour[i+seg_len:]
                        if best_j < i:
                            insert_pos = best_j + 1
                        else:
                            insert_pos = best_j + 1 - seg_len
                        tour = new_tour[:insert_pos] + segment + new_tour[insert_pos:]
                        # Rebuild position array
                        for idx in range(n):
                            pos[tour[idx]] = idx
                        improved = True
                        break

        return tour
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Phase 1: Multi-start construction (10% of time)
    construction_deadline = start_time + (time_limit_ms / 1000.0) * 0.10

    num_starts = min(n, 15)
=======
    # Phase 1: Multi-start construction (8% of time)
    construction_deadline = start_time + (time_limit_ms / 1000.0) * 0.08

    num_starts = min(n, 20)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Phase 3: Iterated Local Search
    no_improve_count = 0
    while time.perf_counter() < deadline - 0.05:
        # Perturb
        perturbed = perturb_tour(best_overall_tour)

        # Local search on perturbed
        remaining = deadline - time.perf_counter()
        mini_deadline = time.perf_counter() + min(remaining * 0.3, 0.2)
        perturbed = two_opt_full(perturbed, mini_deadline)

        if time.perf_counter() < deadline - 0.02:
            mini_deadline = time.perf_counter() + min(remaining * 0.15, 0.1)
            perturbed = or_opt_pass(perturbed, mini_deadline)

        perturbed_length = calc_tour_length(perturbed)

        if perturbed_length < best_overall_length:
            best_overall_length = perturbed_length
            best_overall_tour = perturbed[:]
            no_improve_count = 0
        else:
            no_improve_count += 1

        # If stuck, do more aggressive perturbation
        if no_improve_count > 5:
            tour = best_overall_tour[:]
            no_improve_count = 0
=======
    # Phase 3: Iterated Local Search
    no_improve_count = 0
    perturbation_strength = 1
    while time.perf_counter() < deadline - 0.03:
        # Perturb with adaptive strength
        perturbed = best_overall_tour[:]
        for _ in range(perturbation_strength):
            perturbed = perturb_tour(perturbed)

        # Local search on perturbed
        remaining = deadline - time.perf_counter()
        mini_deadline = time.perf_counter() + min(remaining * 0.4, 0.15)
        perturbed = two_opt_full(perturbed, mini_deadline)

        if time.perf_counter() < deadline - 0.02:
            mini_deadline = time.perf_counter() + min(remaining * 0.2, 0.08)
            perturbed = or_opt_pass(perturbed, mini_deadline)

        perturbed_length = calc_tour_length(perturbed)

        if perturbed_length < best_overall_length:
            best_overall_length = perturbed_length
            best_overall_tour = perturbed[:]
            no_improve_count = 0
            perturbation_strength = 1
        else:
            no_improve_count += 1

        # Increase perturbation strength if stuck
        if no_improve_count > 3:
            perturbation_strength = min(perturbation_strength + 1, 3)
            no_improve_count = 0
>>>>>>> REPLACE
</DIFF>