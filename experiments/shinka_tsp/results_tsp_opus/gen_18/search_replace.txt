Looking at the performance metrics, I notice that the current implementation achieves a combined score of 0.19. Analyzing the code, I see several opportunities for improvement:

1. **The Or-opt pass is doing a full O(n²) search** - it's not using neighbor lists, making it slow for large instances
2. **The greedy insertion is O(n³)** - very slow for large instances, eating up construction time
3. **The ILS phase could benefit from more iterations** with faster local search

Let me propose targeted improvements to make the Or-opt pass use neighbor lists (like the 2-opt does) and optimize the time allocation:

<NAME>
oropt_neighbor_lists_faster_ils
</NAME>

<DESCRIPTION>
This change modifies the Or-opt pass to use neighbor lists instead of doing a full O(n²) search for insertion positions. This makes Or-opt much faster, allowing more ILS iterations. The idea is that good insertion positions for a segment are likely to be near cities that are neighbors of the segment's endpoints. Additionally, I'm adjusting time allocations to allow more ILS iterations with faster local search passes.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def or_opt_pass(tour, deadline):
        tour = list(tour)
        improved = True

        while improved and time.perf_counter() < deadline:
            improved = False

            for seg_len in [1, 2, 3]:
                if improved or time.perf_counter() >= deadline:
                    break

                for i in range(n - seg_len + 1):
                    if time.perf_counter() >= deadline:
                        break

                    prev_i = (i - 1 + n) % n
                    next_seg = i + seg_len

                    if next_seg >= n:
                        continue

                    seg_start = tour[i]
                    seg_end = tour[i + seg_len - 1]
                    prev_city = tour[prev_i]
                    next_city = tour[next_seg]

                    current_cost = dist[prev_city, seg_start] + dist[seg_end, next_city]
                    reconnect_cost = dist[prev_city, next_city]

                    best_delta = 0
                    best_j = -1

                    for j in range(n - 1):
                        if j >= i - 1 and j < i + seg_len:
                            continue

                        city_j = tour[j]
                        city_j1 = tour[j + 1]

                        insert_cost = dist[city_j, seg_start] + dist[seg_end, city_j1]
                        edge_cost = dist[city_j, city_j1]

                        delta = reconnect_cost + insert_cost - current_cost - edge_cost

                        if delta < best_delta - 0.5:
                            best_delta = delta
                            best_j = j

                    if best_j != -1:
                        segment = tour[i:i+seg_len]
                        new_tour = tour[:i] + tour[i+seg_len:]
                        if best_j < i:
                            insert_pos = best_j + 1
                        else:
                            insert_pos = best_j + 1 - seg_len
                        tour = new_tour[:insert_pos] + segment + new_tour[insert_pos:]
                        improved = True
                        break

        return tour
=======
    def or_opt_pass(tour, deadline):
        tour = list(tour)
        pos = [0] * n
        for idx in range(n):
            pos[tour[idx]] = idx

        improved = True

        while improved and time.perf_counter() < deadline:
            improved = False

            for seg_len in [1, 2, 3]:
                if improved or time.perf_counter() >= deadline:
                    break

                for i in range(n - seg_len + 1):
                    if time.perf_counter() >= deadline:
                        break

                    prev_i = (i - 1 + n) % n
                    next_seg = i + seg_len

                    if next_seg >= n:
                        continue

                    seg_start = tour[i]
                    seg_end = tour[i + seg_len - 1]
                    prev_city = tour[prev_i]
                    next_city = tour[next_seg]

                    current_cost = dist[prev_city, seg_start] + dist[seg_end, next_city]
                    reconnect_cost = dist[prev_city, next_city]

                    best_delta = 0
                    best_j = -1

                    # Use neighbor lists to find candidate insertion positions
                    candidate_positions = set()
                    for nc in neighbors[seg_start]:
                        p = pos[nc]
                        if p > 0:
                            candidate_positions.add(p - 1)
                        if p < n - 1:
                            candidate_positions.add(p)
                    for nc in neighbors[seg_end]:
                        p = pos[nc]
                        if p > 0:
                            candidate_positions.add(p - 1)
                        if p < n - 1:
                            candidate_positions.add(p)

                    for j in candidate_positions:
                        if j >= i - 1 and j < i + seg_len:
                            continue
                        if j >= n - 1:
                            continue

                        city_j = tour[j]
                        city_j1 = tour[j + 1]

                        insert_cost = dist[city_j, seg_start] + dist[seg_end, city_j1]
                        edge_cost = dist[city_j, city_j1]

                        delta = reconnect_cost + insert_cost - current_cost - edge_cost

                        if delta < best_delta - 0.5:
                            best_delta = delta
                            best_j = j

                    if best_j != -1:
                        segment = tour[i:i+seg_len]
                        new_tour = tour[:i] + tour[i+seg_len:]
                        if best_j < i:
                            insert_pos = best_j + 1
                        else:
                            insert_pos = best_j + 1 - seg_len
                        tour = new_tour[:insert_pos] + segment + new_tour[insert_pos:]
                        # Rebuild position array
                        for idx in range(n):
                            pos[tour[idx]] = idx
                        improved = True
                        break

        return tour
=======
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Phase 3: Iterated Local Search
    no_improve_count = 0
    perturbation_strength = 1

    while time.perf_counter() < deadline - 0.015:
        perturbed = perturb_tour(best_overall_tour, perturbation_strength)

        remaining = deadline - time.perf_counter()
        mini_deadline = time.perf_counter() + min(remaining * 0.3, 0.08)
        perturbed = two_opt_full(perturbed, mini_deadline)

        if time.perf_counter() < deadline - 0.01:
            mini_deadline = time.perf_counter() + min(remaining * 0.15, 0.04)
            perturbed = or_opt_pass(perturbed, mini_deadline)

        perturbed_length = calc_tour_length(perturbed)

        if perturbed_length < best_overall_length:
            best_overall_length = perturbed_length
            best_overall_tour = perturbed[:]
            no_improve_count = 0
            perturbation_strength = 1
        else:
            no_improve_count += 1

        if no_improve_count > 3:
            perturbation_strength = min(perturbation_strength + 1, 3)
            no_improve_count = 0
=======
    # Phase 3: Iterated Local Search - more iterations with faster local search
    no_improve_count = 0
    perturbation_strength = 1

    while time.perf_counter() < deadline - 0.008:
        perturbed = perturb_tour(best_overall_tour, perturbation_strength)

        remaining = deadline - time.perf_counter()
        mini_deadline = time.perf_counter() + min(remaining * 0.25, 0.05)
        perturbed = two_opt_full(perturbed, mini_deadline)

        if time.perf_counter() < deadline - 0.006:
            mini_deadline = time.perf_counter() + min(remaining * 0.12, 0.025)
            perturbed = or_opt_pass(perturbed, mini_deadline)

        perturbed_length = calc_tour_length(perturbed)

        if perturbed_length < best_overall_length:
            best_overall_length = perturbed_length
            best_overall_tour = perturbed[:]
            no_improve_count = 0
            perturbation_strength = 1
        else:
            no_improve_count += 1

        if no_improve_count > 5:
            perturbation_strength = min(perturbation_strength + 1, 4)
            no_improve_count = 0
>>>>>>> REPLACE
</DIFF>