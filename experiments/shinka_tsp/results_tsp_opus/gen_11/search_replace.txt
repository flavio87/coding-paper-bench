Looking at the performance metrics, I notice that the current implementation achieves a combined score of 0.19, and the best performing variant uses neighbor lists for efficient 2-opt and has greedy edge construction. Let me analyze what improvements could help:

1. The current 2-opt is O(nÂ²) per pass without any acceleration
2. No don't-look bits are used to skip unpromising nodes
3. The perturbation/diversification strategy is missing - once local optimum is found, the search stops

I'll implement a more efficient 2-opt with don't-look bits and add a double-bridge perturbation for Iterated Local Search (ILS), which has proven very effective for TSP.

<NAME>
ils_double_bridge_perturbation
</NAME>

<DESCRIPTION>
This improvement adds:
1. Don't-look bits to 2-opt: Skip nodes that haven't been improved recently, dramatically speeding up 2-opt
2. Iterated Local Search (ILS) with double-bridge perturbation: After reaching a local optimum, apply a 4-opt double-bridge move to escape and continue searching
3. Better time management: Allocate time for construction (10%) and leave 90% for ILS iterations

The double-bridge move is a powerful diversification technique that breaks the tour into 4 segments and reconnects them in a different order, allowing escape from local minima without destroying the tour structure too much.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def two_opt(tour):
        improved = True
        while improved:
            if time.perf_counter() >= deadline:
                break
            improved = False
            for i in range(n - 1):
                for j in range(i + 2, n):
                    if j == n - 1 and i == 0:
                        continue  # Skip if would reverse entire tour

                    a, b = tour[i], tour[i + 1]
                    c, d = tour[j], tour[(j + 1) % n]
                    delta = (dist[a, c] + dist[b, d]) - (dist[a, b] + dist[c, d])

                    if delta < -0.5:
                        tour[i+1:j+1] = tour[i+1:j+1][::-1]
                        improved = True
        return tour
=======
    def two_opt(tour):
        """2-opt with don't-look bits for efficiency."""
        tour = np.array(tour)
        dont_look = np.zeros(n, dtype=bool)
        improved = True

        while improved:
            if time.perf_counter() >= deadline:
                break
            improved = False
            for i in range(n):
                if dont_look[tour[i]]:
                    continue
                if time.perf_counter() >= deadline:
                    break

                improved_i = False
                for j in range(i + 2, n):
                    if j == n - 1 and i == 0:
                        continue  # Skip if would reverse entire tour

                    a, b = tour[i], tour[(i + 1) % n]
                    c, d = tour[j], tour[(j + 1) % n]
                    delta = (dist[a, c] + dist[b, d]) - (dist[a, b] + dist[c, d])

                    if delta < -0.5:
                        tour[i+1:j+1] = tour[i+1:j+1][::-1]
                        improved = True
                        improved_i = True
                        # Reset don't-look bits for affected nodes
                        dont_look[a] = False
                        dont_look[b] = False
                        dont_look[c] = False
                        dont_look[d] = False
                        break

                if not improved_i:
                    dont_look[tour[i]] = True
        return tour
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Apply local search to best tour
    tour = best_tour.copy()

    # Iterative improvement
    prev_length = np.inf
    while time.perf_counter() < deadline:
        tour = two_opt(tour)
        if time.perf_counter() >= deadline:
            break
        tour = or_opt(tour)

        current_length = calc_tour_length(tour)
        if current_length >= prev_length - 0.5:
            break
        prev_length = current_length

    # Calculate final tour length
    length = calc_tour_length(tour)
=======
    def double_bridge(tour):
        """Double-bridge move for escaping local minima (4-opt)."""
        tour = np.array(tour)
        if n < 8:
            return tour

        # Select 4 random cut points ensuring proper spacing
        segment_size = n // 4
        p1 = np.random.randint(1, segment_size + 1)
        p2 = np.random.randint(p1 + 2, p1 + segment_size + 2)
        p3 = np.random.randint(p2 + 2, p2 + segment_size + 2)

        # Ensure p3 doesn't exceed bounds
        p3 = min(p3, n - 2)
        if p2 >= p3:
            p2 = p3 - 2
        if p1 >= p2:
            p1 = p2 - 2
        if p1 < 1:
            p1 = 1

        # Double-bridge reconnection: A-B-C-D -> A-C-B-D
        new_tour = np.concatenate([
            tour[:p1],
            tour[p2:p3],
            tour[p1:p2],
            tour[p3:]
        ])
        return new_tour

    # Apply local search to best tour
    tour = best_tour.copy()
    best_overall_tour = tour.copy()
    best_overall_length = calc_tour_length(tour)

    # Iterated Local Search with double-bridge perturbation
    no_improve_count = 0
    max_no_improve = 5

    while time.perf_counter() < deadline:
        # Local search phase
        prev_length = np.inf
        while time.perf_counter() < deadline:
            tour = two_opt(tour)
            if time.perf_counter() >= deadline:
                break
            tour = or_opt(tour)

            current_length = calc_tour_length(tour)
            if current_length >= prev_length - 0.5:
                break
            prev_length = current_length

        # Update best solution
        current_length = calc_tour_length(tour)
        if current_length < best_overall_length:
            best_overall_length = current_length
            best_overall_tour = tour.copy()
            no_improve_count = 0
        else:
            no_improve_count += 1

        # Check termination
        if time.perf_counter() >= deadline or no_improve_count >= max_no_improve:
            break

        # Perturbation: double-bridge move
        tour = double_bridge(best_overall_tour)

    # Calculate final tour length
    length = best_overall_length
    tour = best_overall_tour
>>>>>>> REPLACE
</DIFF>