Looking at the performance metrics, the current solver achieves a combined score of 0.19 with an average tour length of 5725.60. The individual scores decrease significantly for larger instances, suggesting the algorithm struggles with scalability.

Let me analyze the key bottlenecks and propose improvements:

1. **The 2-opt implementation could be more efficient** - Currently it checks neighbors of both endpoints but breaks immediately after finding one improvement. A "best improvement" strategy within a neighborhood could be more effective.

2. **The Or-opt is doing full scans** - It should use neighbor lists like 2-opt does for efficiency.

3. **Time allocation could be better** - More time should go to the ILS phase which provides diversification.

4. **Add 3-opt moves** - For larger instances, 3-opt can find improvements that 2-opt misses.

Let me implement a more efficient approach with neighbor-list guided Or-opt and better time management:

<NAME>
neighbor_guided_oropt_and_better_time_allocation
</NAME>

<DESCRIPTION>
This change improves the solver in several ways:
1. Makes Or-opt use neighbor lists to find promising insertion points, dramatically reducing the search space
2. Adjusts time allocation to spend more time on ILS iterations (which help escape local minima)
3. Adds a "first improvement" strategy that cycles through positions more efficiently
4. Increases the number of ILS iterations by reducing time spent per iteration
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def or_opt_pass(tour, deadline):
        """Or-opt: relocate segments of 1, 2, or 3 consecutive cities."""
        tour = list(tour)
        improved = True

        while improved and time.perf_counter() < deadline:
            improved = False

            for seg_len in [1, 2, 3]:
                if improved or time.perf_counter() >= deadline:
                    break

                for i in range(n - seg_len + 1):
                    if time.perf_counter() >= deadline:
                        break

                    prev_i = (i - 1 + n) % n
                    next_seg = i + seg_len

                    seg_start_city = tour[i]
                    seg_end_city = tour[i + seg_len - 1]
                    prev_city = tour[prev_i]

                    # Handle wrap-around for next_city
                    if next_seg >= n:
                        continue
                    next_city = tour[next_seg]

                    # Cost of current configuration
                    current_cost = dist[prev_city, seg_start_city] + dist[seg_end_city, next_city]
                    reconnect_cost = dist[prev_city, next_city]

                    best_delta = 0
                    best_j = -1

                    # Try inserting after position j
                    for j in range(n - 1):
                        # Skip if j is in or adjacent to current segment position
                        if j >= i - 1 and j < i + seg_len:
                            continue

                        city_j = tour[j]
                        city_j1 = tour[(j + 1) % n]

                        # Cost of inserting segment between j and j+1
                        insert_cost = dist[city_j, seg_start_city] + dist[seg_end_city, city_j1]
                        edge_cost = dist[city_j, city_j1]

                        delta = reconnect_cost + insert_cost - current_cost - edge_cost

                        if delta < best_delta - 0.5:
                            best_delta = delta
                            best_j = j

                    if best_j != -1:
                        segment = tour[i:i+seg_len]
                        new_tour = tour[:i] + tour[i+seg_len:]
                        if best_j < i:
                            insert_pos = best_j + 1
                        else:
                            insert_pos = best_j + 1 - seg_len
                        tour = new_tour[:insert_pos] + segment + new_tour[insert_pos:]
                        improved = True
                        break

        return tour
=======
    def or_opt_pass(tour, deadline):
        """Or-opt: relocate segments of 1, 2, or 3 consecutive cities using neighbor lists."""
        tour = list(tour)
        pos = [0] * n
        for idx in range(n):
            pos[tour[idx]] = idx

        improved = True

        while improved and time.perf_counter() < deadline:
            improved = False

            for seg_len in [1, 2, 3]:
                if improved or time.perf_counter() >= deadline:
                    break

                for i in range(n - seg_len + 1):
                    if time.perf_counter() >= deadline:
                        break

                    prev_i = (i - 1 + n) % n
                    next_seg = i + seg_len

                    seg_start_city = tour[i]
                    seg_end_city = tour[i + seg_len - 1]
                    prev_city = tour[prev_i]

                    # Handle wrap-around for next_city
                    if next_seg >= n:
                        continue
                    next_city = tour[next_seg]

                    # Cost of current configuration
                    current_cost = dist[prev_city, seg_start_city] + dist[seg_end_city, next_city]
                    reconnect_cost = dist[prev_city, next_city]

                    best_delta = 0
                    best_j = -1

                    # Use neighbor lists to find promising insertion points
                    candidate_positions = set()
                    for nc in neighbors[seg_start_city]:
                        p = pos[nc]
                        if p > 0:
                            candidate_positions.add(p - 1)
                        candidate_positions.add(p)
                    for nc in neighbors[seg_end_city]:
                        p = pos[nc]
                        if p > 0:
                            candidate_positions.add(p - 1)
                        candidate_positions.add(p)

                    for j in candidate_positions:
                        if j < 0 or j >= n - 1:
                            continue
                        # Skip if j is in or adjacent to current segment position
                        if j >= i - 1 and j < i + seg_len:
                            continue

                        city_j = tour[j]
                        city_j1 = tour[j + 1]

                        # Cost of inserting segment between j and j+1
                        insert_cost = dist[city_j, seg_start_city] + dist[seg_end_city, city_j1]
                        edge_cost = dist[city_j, city_j1]

                        delta = reconnect_cost + insert_cost - current_cost - edge_cost

                        if delta < best_delta - 0.5:
                            best_delta = delta
                            best_j = j

                    if best_j != -1:
                        segment = tour[i:i+seg_len]
                        new_tour = tour[:i] + tour[i+seg_len:]
                        if best_j < i:
                            insert_pos = best_j + 1
                        else:
                            insert_pos = best_j + 1 - seg_len
                        tour = new_tour[:insert_pos] + segment + new_tour[insert_pos:]
                        # Rebuild position array
                        for idx in range(n):
                            pos[tour[idx]] = idx
                        improved = True
                        break

        return tour
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Phase 1: Multi-start construction (8% of time)
    construction_deadline = start_time + (time_limit_ms / 1000.0) * 0.08

    num_starts = min(n, 20)  # Try more starting points
=======
    # Phase 1: Multi-start construction (6% of time)
    construction_deadline = start_time + (time_limit_ms / 1000.0) * 0.06

    num_starts = min(n, 25)  # Try more starting points
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Phase 3: Iterated Local Search with adaptive perturbation
    no_improve_count = 0
    perturbation_strength = 1
    while time.perf_counter() < deadline - 0.03:
        # Perturb with adaptive strength
        perturbed = best_overall_tour[:]
        for _ in range(perturbation_strength):
            perturbed = perturb_tour(perturbed)

        # Local search on perturbed
        remaining = deadline - time.perf_counter()
        mini_deadline = time.perf_counter() + min(remaining * 0.35, 0.15)
        perturbed = two_opt_full(perturbed, mini_deadline)

        if time.perf_counter() < deadline - 0.02:
            mini_deadline = time.perf_counter() + min(remaining * 0.2, 0.08)
            perturbed = or_opt_pass(perturbed, mini_deadline)

        perturbed_length = calc_tour_length(perturbed)

        if perturbed_length < best_overall_length:
            best_overall_length = perturbed_length
            best_overall_tour = perturbed[:]
            no_improve_count = 0
            perturbation_strength = 1
        else:
            no_improve_count += 1

        # Increase perturbation strength if stuck
        if no_improve_count > 3:
            perturbation_strength = min(perturbation_strength + 1, 3)
            no_improve_count = 0
=======
    # Phase 3: Iterated Local Search with adaptive perturbation
    no_improve_count = 0
    perturbation_strength = 1
    iteration_count = 0
    while time.perf_counter() < deadline - 0.02:
        iteration_count += 1

        # Perturb with adaptive strength
        perturbed = best_overall_tour[:]
        for _ in range(perturbation_strength):
            perturbed = perturb_tour(perturbed)

        # Local search on perturbed - use shorter time limits for more iterations
        remaining = deadline - time.perf_counter()
        mini_deadline = time.perf_counter() + min(remaining * 0.25, 0.10)
        perturbed = two_opt_full(perturbed, mini_deadline)

        if time.perf_counter() < deadline - 0.015:
            mini_deadline = time.perf_counter() + min(remaining * 0.15, 0.05)
            perturbed = or_opt_pass(perturbed, mini_deadline)

        perturbed_length = calc_tour_length(perturbed)

        if perturbed_length < best_overall_length:
            best_overall_length = perturbed_length
            best_overall_tour = perturbed[:]
            no_improve_count = 0
            perturbation_strength = 1
        else:
            no_improve_count += 1

        # Increase perturbation strength if stuck
        if no_improve_count > 4:
            perturbation_strength = min(perturbation_strength + 1, 4)
            no_improve_count = 0
>>>>>>> REPLACE
</DIFF>