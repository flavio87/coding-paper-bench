Looking at the current implementation, I can see several opportunities for improvement:

1. **The Or-opt implementation has bugs** - it modifies the tour array while iterating, which can cause issues
2. **We're not using all available time effectively** - we could do more iterations of local search
3. **3-opt moves could find improvements that 2-opt misses**
4. **We could use a greedy/savings-based construction which often beats nearest neighbor**

Let me propose a fix for the Or-opt implementation and add a more efficient 2-opt with don't-look bits, plus better time management.

<NAME>
fix_oropt_and_add_3opt
</NAME>

<DESCRIPTION>
The current Or-opt implementation has issues with array modification during iteration. I'll fix this and also add:
1. A more efficient 2-opt implementation using don't-look bits to skip nodes that haven't changed
2. Add 3-opt moves for deeper local search
3. Better time management to use more of the available time budget
4. Use a farthest insertion heuristic as an alternative construction method
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def two_opt(tour):
        improved = True
        while improved:
            if time.perf_counter() >= deadline:
                break
            improved = False
            for i in range(n - 1):
                for j in range(i + 2, n):
                    if j == n - 1 and i == 0:
                        continue  # Skip if would reverse entire tour

                    a, b = tour[i], tour[i + 1]
                    c, d = tour[j], tour[(j + 1) % n]
                    delta = (dist[a, c] + dist[b, d]) - (dist[a, b] + dist[c, d])

                    if delta < -0.5:
                        tour[i+1:j+1] = tour[i+1:j+1][::-1]
                        improved = True
        return tour
=======
    def two_opt(tour):
        """2-opt with don't-look bits for efficiency"""
        dont_look = np.zeros(n, dtype=bool)
        improved = True
        while improved:
            if time.perf_counter() >= deadline:
                break
            improved = False
            for i in range(n):
                if dont_look[tour[i]]:
                    continue
                i_improved = False
                for j in range(i + 2, n):
                    if j == n - 1 and i == 0:
                        continue

                    a, b = tour[i], tour[i + 1]
                    c, d = tour[j], tour[(j + 1) % n]
                    delta = (dist[a, c] + dist[b, d]) - (dist[a, b] + dist[c, d])

                    if delta < -0.5:
                        tour[i+1:j+1] = tour[i+1:j+1][::-1]
                        dont_look[a] = False
                        dont_look[b] = False
                        dont_look[c] = False
                        dont_look[d] = False
                        improved = True
                        i_improved = True
                        break
                if not i_improved:
                    dont_look[tour[i]] = True
        return tour
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def or_opt(tour):
        """Or-opt: relocate segments of 1-3 cities"""
        improved = True
        while improved:
            if time.perf_counter() >= deadline:
                break
            improved = False
            for seg_len in [1, 2, 3]:  # Try segments of length 1, 2, 3
                if improved:
                    break
                for i in range(n):
                    if improved:
                        break
                    if time.perf_counter() >= deadline:
                        break
                    # Segment from i to i+seg_len-1
                    if i + seg_len > n:
                        continue

                    # Current cost of segment edges
                    prev_i = (i - 1) % n
                    next_seg = (i + seg_len) % n

                    # Cost to remove segment
                    old_cost = dist[tour[prev_i], tour[i]] + dist[tour[(i + seg_len - 1) % n], tour[next_seg]]
                    # Cost to connect prev to next (bypassing segment)
                    bypass_cost = dist[tour[prev_i], tour[next_seg]]

                    # Try inserting segment elsewhere
                    for j in range(n):
                        if j >= i - 1 and j <= i + seg_len:
                            continue  # Skip positions that overlap with current

                        next_j = (j + 1) % n
                        # Cost to insert segment between j and j+1
                        insert_old = dist[tour[j], tour[next_j]]
                        insert_new = dist[tour[j], tour[i]] + dist[tour[(i + seg_len - 1) % n], tour[next_j]]

                        delta = bypass_cost + insert_new - old_cost - insert_old

                        if delta < -0.5:
                            # Perform the move
                            segment = tour[i:i+seg_len].copy()
                            new_tour = np.concatenate([
                                tour[:i],
                                tour[i+seg_len:]
                            ])
                            # Find new position for j (adjusted for removal)
                            new_j = j if j < i else j - seg_len
                            new_tour = np.concatenate([
                                new_tour[:new_j+1],
                                segment,
                                new_tour[new_j+1:]
                            ])
                            tour[:] = new_tour
                            improved = True
                            break
        return tour
=======
    def or_opt(tour):
        """Or-opt: relocate segments of 1-3 cities (fixed implementation)"""
        improved = True
        while improved:
            if time.perf_counter() >= deadline:
                break
            improved = False
            for seg_len in [1, 2, 3]:
                if improved:
                    break
                for i in range(n - seg_len + 1):
                    if improved or time.perf_counter() >= deadline:
                        break

                    # Get segment indices
                    seg_start = i
                    seg_end = i + seg_len - 1
                    prev_i = (i - 1) % n
                    next_seg = (seg_end + 1) % n

                    # Current edges cost
                    remove_cost = dist[tour[prev_i], tour[seg_start]] + dist[tour[seg_end], tour[next_seg]]
                    connect_cost = dist[tour[prev_i], tour[next_seg]]

                    # Try inserting segment at other positions
                    for j in range(n):
                        # Skip invalid positions
                        if j >= prev_i and j <= seg_end:
                            continue
                        if (j + 1) % n >= seg_start and (j + 1) % n <= next_seg:
                            continue

                        next_j = (j + 1) % n

                        # Cost change
                        old_edge = dist[tour[j], tour[next_j]]
                        new_edges = dist[tour[j], tour[seg_start]] + dist[tour[seg_end], tour[next_j]]

                        delta = connect_cost + new_edges - remove_cost - old_edge

                        if delta < -0.5:
                            # Create new tour by removing segment and inserting elsewhere
                            tour_list = tour.tolist()
                            segment = tour_list[seg_start:seg_end+1]
                            del tour_list[seg_start:seg_end+1]

                            # Adjust insertion position
                            insert_pos = j + 1 if j < seg_start else j + 1 - seg_len
                            if insert_pos < 0:
                                insert_pos = 0
                            if insert_pos > len(tour_list):
                                insert_pos = len(tour_list)

                            for k, city in enumerate(segment):
                                tour_list.insert(insert_pos + k, city)

                            tour[:] = np.array(tour_list)
                            improved = True
                            break
        return tour

    def three_opt_move(tour):
        """Limited 3-opt: try a few 3-opt moves"""
        best_delta = 0
        best_move = None

        # Only try a subset of 3-opt moves due to O(n^3) complexity
        step = max(1, n // 30)

        for i in range(0, n - 4, step):
            if time.perf_counter() >= deadline:
                break
            for j in range(i + 2, n - 2, step):
                for k in range(j + 2, n, step):
                    if k == n - 1 and i == 0:
                        continue

                    a, b = tour[i], tour[i + 1]
                    c, d = tour[j], tour[j + 1]
                    e, f = tour[k], tour[(k + 1) % n]

                    # Original cost
                    d0 = dist[a, b] + dist[c, d] + dist[e, f]

                    # Try different reconnections
                    # Reconnection 1: a-c, b-e, d-f
                    d1 = dist[a, c] + dist[b, e] + dist[d, f]
                    if d1 - d0 < best_delta:
                        best_delta = d1 - d0
                        best_move = ('3opt1', i, j, k)

        if best_move and best_delta < -0.5:
            _, i, j, k = best_move
            # Apply the move: reverse segment [i+1:j+1] and [j+1:k+1]
            tour[i+1:j+1] = tour[i+1:j+1][::-1]
            tour[j+1:k+1] = tour[j+1:k+1][::-1]
            return True
        return False
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Iterative improvement
    prev_length = np.inf
    while time.perf_counter() < deadline:
        tour = two_opt(tour)
        if time.perf_counter() >= deadline:
            break
        tour = or_opt(tour)

        current_length = calc_tour_length(tour)
        if current_length >= prev_length - 0.5:
            break
        prev_length = current_length
=======
    # Iterative improvement with multiple phases
    prev_length = np.inf
    no_improve_count = 0
    max_no_improve = 3

    while time.perf_counter() < deadline and no_improve_count < max_no_improve:
        tour = two_opt(tour)
        if time.perf_counter() >= deadline:
            break

        tour = or_opt(tour)
        if time.perf_counter() >= deadline:
            break

        # Try 3-opt occasionally
        if n <= 500:  # Only for smaller instances
            three_opt_move(tour)

        current_length = calc_tour_length(tour)
        if current_length >= prev_length - 0.5:
            no_improve_count += 1
            # Try perturbing the tour slightly
            if no_improve_count < max_no_improve and n > 10:
                # Double-bridge move for diversification
                pos = sorted(np.random.choice(n, 4, replace=False))
                p1, p2, p3, p4 = pos
                new_tour = np.concatenate([
                    tour[:p1+1],
                    tour[p3+1:p4+1],
                    tour[p2+1:p3+1],
                    tour[p1+1:p2+1],
                    tour[p4+1:]
                ])
                tour = new_tour
        else:
            no_improve_count = 0
        prev_length = current_length
>>>>>>> REPLACE
</DIFF>