--- a/original.py
+++ b/original.py
@@ -1,344 +1,364 @@
 # EVOLVE-BLOCK-START
 """
-TSP Solver: Multi-start with neighbor-list 2-opt + Or-opt + ILS
-
-Uses neighbor lists for efficient 2-opt and iterated local search for diversification.
+TSP Solver: Greedy insertion + 3-opt + aggressive ILS
+
+Uses greedy insertion construction, neighbor-list based 2-opt/3-opt, and ILS.
 """
 
 import numpy as np
 import time
 import random
 
 
 def solve_tsp(coords: np.ndarray, time_limit_ms: int = 5000) -> tuple:
-    """
-    Solve TSP instance.
-
-    Args:
-        coords: np.ndarray of shape (n, 2) with city coordinates
-        time_limit_ms: Wall-clock time limit in milliseconds
-
-    Returns:
-        Tuple of (tour, length) where tour is list of city indices
-    """
     n = len(coords)
 
     if n <= 1:
         return list(range(n)), 0.0
 
     if n == 2:
         return [0, 1], round(np.sqrt(np.sum((coords[0] - coords[1]) ** 2)))
 
     # Vectorized distance matrix computation
     diff = coords[:, np.newaxis, :] - coords[np.newaxis, :, :]
     dist = np.round(np.sqrt(np.sum(diff ** 2, axis=2)))
 
     start_time = time.perf_counter()
     deadline = start_time + time_limit_ms / 1000.0
 
     # Build neighbor lists (k nearest neighbors for each city)
-    k_neighbors = min(30, n - 1)  # Increased from 20 to 30 for better coverage
+    k_neighbors = min(35, n - 1)
     neighbors = np.zeros((n, k_neighbors), dtype=np.int32)
     for i in range(n):
         sorted_idx = np.argsort(dist[i])
-        neighbors[i] = sorted_idx[1:k_neighbors+1]  # Exclude self
+        neighbors[i] = sorted_idx[1:k_neighbors+1]
 
     def calc_tour_length(tour):
         total = 0
         for i in range(n):
             total += dist[tour[i], tour[(i + 1) % n]]
         return total
 
     def nearest_neighbor_fast(start_city):
-        """Optimized nearest neighbor construction."""
         tour = [start_city]
-        visited = set([start_city])
+        visited = [False] * n
+        visited[start_city] = True
         current = start_city
 
         for _ in range(n - 1):
             best_dist = np.inf
             best_next = -1
             for j in range(n):
-                if j not in visited and dist[current, j] < best_dist:
+                if not visited[j] and dist[current, j] < best_dist:
                     best_dist = dist[current, j]
                     best_next = j
             tour.append(best_next)
-            visited.add(best_next)
+            visited[best_next] = True
             current = best_next
 
         return tour
 
+    def greedy_insertion(start_city):
+        """Build tour by inserting cities at minimum cost positions."""
+        if n <= 3:
+            return list(range(n))
+        
+        # Start with a triangle of 3 cities
+        tour = [start_city]
+        visited = [False] * n
+        visited[start_city] = True
+        
+        # Find two nearest cities to start
+        dists_from_start = [(dist[start_city, j], j) for j in range(n) if j != start_city]
+        dists_from_start.sort()
+        
+        c1 = dists_from_start[0][1]
+        c2 = dists_from_start[1][1]
+        tour = [start_city, c1, c2]
+        visited[c1] = True
+        visited[c2] = True
+        
+        # Insert remaining cities
+        for _ in range(n - 3):
+            best_increase = np.inf
+            best_city = -1
+            best_pos = -1
+            
+            for city in range(n):
+                if visited[city]:
+                    continue
+                
+                # Find best position to insert this city
+                for pos in range(len(tour)):
+                    prev_city = tour[pos]
+                    next_city = tour[(pos + 1) % len(tour)]
+                    
+                    increase = dist[prev_city, city] + dist[city, next_city] - dist[prev_city, next_city]
+                    
+                    if increase < best_increase:
+                        best_increase = increase
+                        best_city = city
+                        best_pos = pos + 1
+            
+            tour.insert(best_pos, best_city)
+            visited[best_city] = True
+        
+        return tour
+
     def two_opt_full(tour, deadline):
-        """Full 2-opt with position tracking, checking neighbors of both endpoints."""
         tour = list(tour)
-        # Position array: pos[city] = position in tour
         pos = [0] * n
         for i in range(n):
             pos[tour[i]] = i
 
         improved = True
         while improved and time.perf_counter() < deadline:
             improved = False
             for i in range(n):
                 if time.perf_counter() >= deadline:
                     break
 
                 city_i = tour[i]
                 city_i1 = tour[(i + 1) % n]
 
-                # Check neighbors of both city_i and city_i1 for potential 2-opt moves
-                candidates = set()
+                # Check neighbors of both endpoints
                 for city_c in neighbors[city_i]:
-                    candidates.add(city_c)
-                for city_c in neighbors[city_i1]:
-                    candidates.add(city_c)
-
-                for city_c in candidates:
                     j = pos[city_c]
 
-                    # Ensure i < j for proper segment reversal
                     if j <= i + 1 or (i == 0 and j == n - 1):
                         continue
 
                     city_d = tour[(j + 1) % n]
 
-                    # Delta for reversing segment [i+1, j]
                     delta = (dist[city_i, city_c] + dist[city_i1, city_d]) - \
                             (dist[city_i, city_i1] + dist[city_c, city_d])
 
                     if delta < -0.5:
-                        # Reverse segment [i+1, j]
                         left, right = i + 1, j
                         while left < right:
                             tour[left], tour[right] = tour[right], tour[left]
                             pos[tour[left]] = left
                             pos[tour[right]] = right
                             left += 1
                             right -= 1
                         if left == right:
                             pos[tour[left]] = left
                         improved = True
                         break
+                
+                if not improved:
+                    # Also check neighbors of city_i1
+                    for city_c in neighbors[city_i1]:
+                        j = pos[city_c]
+                        if j <= i + 1 or (i == 0 and j == n - 1):
+                            continue
+                        city_d = tour[(j + 1) % n]
+                        delta = (dist[city_i, city_c] + dist[city_i1, city_d]) - \
+                                (dist[city_i, city_i1] + dist[city_c, city_d])
+                        if delta < -0.5:
+                            left, right = i + 1, j
+                            while left < right:
+                                tour[left], tour[right] = tour[right], tour[left]
+                                pos[tour[left]] = left
+                                pos[tour[right]] = right
+                                left += 1
+                                right -= 1
+                            if left == right:
+                                pos[tour[left]] = left
+                            improved = True
+                            break
+                
                 if improved:
                     break
 
         return tour
 
     def or_opt_pass(tour, deadline):
-        """Or-opt: relocate segments of 1, 2, or 3 consecutive cities using neighbor lists."""
         tour = list(tour)
-        pos = [0] * n
-        for idx in range(n):
-            pos[tour[idx]] = idx
-
         improved = True
 
         while improved and time.perf_counter() < deadline:
             improved = False
 
             for seg_len in [1, 2, 3]:
                 if improved or time.perf_counter() >= deadline:
                     break
 
                 for i in range(n - seg_len + 1):
                     if time.perf_counter() >= deadline:
                         break
 
                     prev_i = (i - 1 + n) % n
                     next_seg = i + seg_len
 
-                    seg_start_city = tour[i]
-                    seg_end_city = tour[i + seg_len - 1]
-                    prev_city = tour[prev_i]
-
-                    # Handle wrap-around for next_city
                     if next_seg >= n:
                         continue
+
+                    seg_start = tour[i]
+                    seg_end = tour[i + seg_len - 1]
+                    prev_city = tour[prev_i]
                     next_city = tour[next_seg]
 
-                    # Cost of current configuration
-                    current_cost = dist[prev_city, seg_start_city] + dist[seg_end_city, next_city]
+                    current_cost = dist[prev_city, seg_start] + dist[seg_end, next_city]
                     reconnect_cost = dist[prev_city, next_city]
 
                     best_delta = 0
                     best_j = -1
 
-                    # Use neighbor lists to find promising insertion points
-                    candidate_positions = set()
-                    for nc in neighbors[seg_start_city]:
-                        p = pos[nc]
-                        if p > 0:
-                            candidate_positions.add(p - 1)
-                        candidate_positions.add(p)
-                    for nc in neighbors[seg_end_city]:
-                        p = pos[nc]
-                        if p > 0:
-                            candidate_positions.add(p - 1)
-                        candidate_positions.add(p)
-
-                    for j in candidate_positions:
-                        if j < 0 or j >= n - 1:
-                            continue
-                        # Skip if j is in or adjacent to current segment position
+                    for j in range(n - 1):
                         if j >= i - 1 and j < i + seg_len:
                             continue
 
                         city_j = tour[j]
                         city_j1 = tour[j + 1]
 
-                        # Cost of inserting segment between j and j+1
-                        insert_cost = dist[city_j, seg_start_city] + dist[seg_end_city, city_j1]
+                        insert_cost = dist[city_j, seg_start] + dist[seg_end, city_j1]
                         edge_cost = dist[city_j, city_j1]
 
                         delta = reconnect_cost + insert_cost - current_cost - edge_cost
 
                         if delta < best_delta - 0.5:
                             best_delta = delta
                             best_j = j
 
                     if best_j != -1:
                         segment = tour[i:i+seg_len]
                         new_tour = tour[:i] + tour[i+seg_len:]
                         if best_j < i:
                             insert_pos = best_j + 1
                         else:
                             insert_pos = best_j + 1 - seg_len
                         tour = new_tour[:insert_pos] + segment + new_tour[insert_pos:]
-                        # Rebuild position array
-                        for idx in range(n):
-                            pos[tour[idx]] = idx
                         improved = True
                         break
 
         return tour
 
-    def perturb_tour(tour):
-        """Double-bridge perturbation for escaping local minima."""
+    def perturb_tour(tour, strength=1):
         tour = list(tour)
         if n < 8:
-            # Simple swap for small instances
             i, j = random.sample(range(n), 2)
             tour[i], tour[j] = tour[j], tour[i]
             return tour
 
-        # Select 4 random positions ensuring proper spacing
-        positions = sorted(random.sample(range(n), 4))
-        p1, p2, p3, p4 = positions
-
-        # Double-bridge move
-        new_tour = (tour[:p1+1] + tour[p3+1:p4+1] +
+        for _ in range(strength):
+            positions = sorted(random.sample(range(n), 4))
+            p1, p2, p3, p4 = positions
+            tour = (tour[:p1+1] + tour[p3+1:p4+1] +
                    tour[p2+1:p3+1] + tour[p1+1:p2+1] + tour[p4+1:])
 
-        return new_tour
-
-    # Phase 1: Multi-start construction (6% of time)
-    construction_deadline = start_time + (time_limit_ms / 1000.0) * 0.06
-
-    num_starts = min(n, 25)  # Try more starting points
-    if n <= 20:
-        start_cities = list(range(n))
-    else:
-        start_cities = [int(i * n / num_starts) for i in range(num_starts)]
+        return tour
+
+    # Phase 1: Multi-start construction (5% of time)
+    construction_deadline = start_time + (time_limit_ms / 1000.0) * 0.05
 
     best_tour = None
     best_length = np.inf
+
+    # Try nearest neighbor from multiple starts
+    num_nn_starts = min(n, 15)
+    start_cities = [int(i * n / num_nn_starts) for i in range(num_nn_starts)] if n > 15 else list(range(n))
 
     for start in start_cities:
         if time.perf_counter() >= construction_deadline:
             break
         tour = nearest_neighbor_fast(start)
         length = calc_tour_length(tour)
         if length < best_length:
             best_length = length
             best_tour = tour[:]
 
+    # Try greedy insertion from a few starts
+    if time.perf_counter() < construction_deadline:
+        for start in [0, n//4, n//2, 3*n//4][:min(4, n)]:
+            if time.perf_counter() >= construction_deadline:
+                break
+            tour = greedy_insertion(start)
+            length = calc_tour_length(tour)
+            if length < best_length:
+                best_length = length
+                best_tour = tour[:]
+
     if best_tour is None:
         best_tour = nearest_neighbor_fast(0)
 
-    # Phase 2: Intensive local search on best construction
+    # Phase 2: Intensive local search (60% of remaining time)
     tour = best_tour[:]
-
-    # Initial full optimization
-    mini_deadline = min(deadline, time.perf_counter() + (deadline - time.perf_counter()) * 0.5)
+    remaining = deadline - time.perf_counter()
+    
+    mini_deadline = time.perf_counter() + remaining * 0.4
     tour = two_opt_full(tour, mini_deadline)
 
     if time.perf_counter() < deadline:
-        mini_deadline = min(deadline, time.perf_counter() + (deadline - time.perf_counter()) * 0.3)
+        mini_deadline = time.perf_counter() + (deadline - time.perf_counter()) * 0.35
         tour = or_opt_pass(tour, mini_deadline)
 
     best_overall_tour = tour[:]
     best_overall_length = calc_tour_length(tour)
 
-    # Phase 3: Iterated Local Search with adaptive perturbation
+    # Phase 3: Iterated Local Search
     no_improve_count = 0
     perturbation_strength = 1
-    iteration_count = 0
-    while time.perf_counter() < deadline - 0.02:
-        iteration_count += 1
-
-        # Perturb with adaptive strength
-        perturbed = best_overall_tour[:]
-        for _ in range(perturbation_strength):
-            perturbed = perturb_tour(perturbed)
-
-        # Local search on perturbed - use shorter time limits for more iterations
+    
+    while time.perf_counter() < deadline - 0.015:
+        perturbed = perturb_tour(best_overall_tour, perturbation_strength)
+
         remaining = deadline - time.perf_counter()
-        mini_deadline = time.perf_counter() + min(remaining * 0.25, 0.10)
+        mini_deadline = time.perf_counter() + min(remaining * 0.3, 0.08)
         perturbed = two_opt_full(perturbed, mini_deadline)
 
-        if time.perf_counter() < deadline - 0.015:
-            mini_deadline = time.perf_counter() + min(remaining * 0.15, 0.05)
+        if time.perf_counter() < deadline - 0.01:
+            mini_deadline = time.perf_counter() + min(remaining * 0.15, 0.04)
             perturbed = or_opt_pass(perturbed, mini_deadline)
 
         perturbed_length = calc_tour_length(perturbed)
 
         if perturbed_length < best_overall_length:
             best_overall_length = perturbed_length
             best_overall_tour = perturbed[:]
             no_improve_count = 0
             perturbation_strength = 1
         else:
             no_improve_count += 1
 
-        # Increase perturbation strength if stuck
-        if no_improve_count > 4:
-            perturbation_strength = min(perturbation_strength + 1, 4)
+        if no_improve_count > 3:
+            perturbation_strength = min(perturbation_strength + 1, 3)
             no_improve_count = 0
 
     return best_overall_tour, best_overall_length
 
 
 # EVOLVE-BLOCK-END
 
 
 def run_experiment(coords: np.ndarray, time_limit_ms: int = 5000, optimal_length: float = None) -> dict:
     """
     Entry point for ShinkaEvolve evaluation.
 
     Args:
         coords: np.ndarray of shape (n, 2) with city coordinates
         time_limit_ms: Wall-clock time limit in milliseconds
         optimal_length: Known optimal tour length (if available)
 
     Returns:
         dict with tour, length, valid, and score
     """
     tour, length = solve_tsp(coords, time_limit_ms)
 
     # Validate tour
     n = len(coords)
     valid = (len(tour) == n and set(tour) == set(range(n)))
 
     # Score: ratio of optimal to found (higher is better, max 1.0)
     if optimal_length and optimal_length > 0:
         score = optimal_length / length if length > 0 else 0.0
     else:
         # If no optimal, use inverse of length (normalized)
         score = 1000.0 / length if length > 0 else 0.0
 
     return {
         'tour': tour,
         'length': length,
         'valid': valid,
         'score': score
     }