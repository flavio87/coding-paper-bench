Looking at the performance metrics, I notice that the current implementation has room for improvement. Let me analyze the code and propose targeted optimizations.

Key observations:
1. The nearest neighbor construction is using a slow O(nÂ²) loop instead of vectorized operations
2. The 2-opt implementation doesn't use neighbor lists for acceleration
3. The perturbation acceptance is too greedy - it should sometimes accept worse solutions to escape local minima

I'll implement several improvements:
1. Use vectorized nearest neighbor construction
2. Add k-nearest neighbor acceleration to 2-opt
3. Implement simulated annealing acceptance criterion for perturbations
4. Add a farthest insertion heuristic as an alternative construction method

<NAME>
accelerated_2opt_with_neighbor_lists_and_sa
</NAME>

<DESCRIPTION>
This edit improves the solver by:
1. Using vectorized nearest neighbor construction for faster initial tour building
2. Adding k-nearest neighbor lists to accelerate 2-opt by only checking promising edges
3. Implementing simulated annealing acceptance for perturbations to better escape local minima
4. Adding farthest insertion as an alternative construction heuristic
5. Increasing diversification through more aggressive perturbation acceptance
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def calc_tour_length(tour):
        total = 0
        for i in range(n):
            total += dist[tour[i], tour[(i + 1) % n]]
        return total

    def nearest_neighbor_fast(start_city):
        """Optimized nearest neighbor construction."""
        tour = [start_city]
        visited = set([start_city])
        current = start_city

        for _ in range(n - 1):
            best_dist = np.inf
            best_next = -1
            for j in range(n):
                if j not in visited and dist[current, j] < best_dist:
                    best_dist = dist[current, j]
                    best_next = j
            tour.append(best_next)
            visited.add(best_next)
            current = best_next

        return tour
=======
    def calc_tour_length(tour):
        total = 0
        for i in range(n):
            total += dist[tour[i], tour[(i + 1) % n]]
        return total

    # Precompute k-nearest neighbors for faster 2-opt
    k_neighbors = min(20, n - 1)
    neighbor_list = np.argsort(dist, axis=1)[:, 1:k_neighbors+1]

    def nearest_neighbor_fast(start_city):
        """Vectorized nearest neighbor construction."""
        tour = np.zeros(n, dtype=np.int32)
        visited = np.zeros(n, dtype=bool)
        tour[0] = start_city
        visited[start_city] = True
        current = start_city

        for step in range(1, n):
            dists = dist[current].copy()
            dists[visited] = np.inf
            best_next = np.argmin(dists)
            tour[step] = best_next
            visited[best_next] = True
            current = best_next

        return tour.tolist()

    def farthest_insertion():
        """Farthest insertion heuristic - often produces good initial tours."""
        if n < 3:
            return list(range(n))

        # Start with two farthest cities
        max_dist = 0
        c1, c2 = 0, 1
        for i in range(n):
            for j in range(i + 1, n):
                if dist[i, j] > max_dist:
                    max_dist = dist[i, j]
                    c1, c2 = i, j

        tour = [c1, c2]
        in_tour = np.zeros(n, dtype=bool)
        in_tour[c1] = True
        in_tour[c2] = True

        while len(tour) < n:
            if time.perf_counter() >= deadline:
                break

            # Find farthest city from tour
            max_min_dist = -1
            farthest = -1
            for c in range(n):
                if in_tour[c]:
                    continue
                min_dist = min(dist[c, tour[i]] for i in range(len(tour)))
                if min_dist > max_min_dist:
                    max_min_dist = min_dist
                    farthest = c

            if farthest == -1:
                break

            # Find best position to insert
            best_increase = np.inf
            best_pos = 0
            for i in range(len(tour)):
                j = (i + 1) % len(tour)
                increase = dist[tour[i], farthest] + dist[farthest, tour[j]] - dist[tour[i], tour[j]]
                if increase < best_increase:
                    best_increase = increase
                    best_pos = i + 1

            tour.insert(best_pos, farthest)
            in_tour[farthest] = True

        return tour
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def two_opt_pass(tour, deadline):
        """Single pass of 2-opt with don't-look bits."""
        tour = list(tour)
        improved = True
        dont_look = [False] * n

        while improved and time.perf_counter() < deadline:
            improved = False
            for i in range(n):
                if dont_look[i]:
                    continue
                if time.perf_counter() >= deadline:
                    break

                improved_i = False
                for j in range(i + 2, n):
                    if j == n - 1 and i == 0:
                        continue

                    # Get indices in tour
                    a, b = tour[i], tour[(i + 1) % n]
                    c, d = tour[j], tour[(j + 1) % n]

                    delta = (dist[a, c] + dist[b, d]) - (dist[a, b] + dist[c, d])

                    if delta < -0.5:
                        # Reverse segment
                        tour[i+1:j+1] = tour[i+1:j+1][::-1]
                        improved = True
                        improved_i = True
                        # Reset don't-look bits for affected cities
                        dont_look[tour[i]] = False
                        dont_look[tour[(i+1) % n]] = False
                        dont_look[tour[j]] = False
                        dont_look[tour[(j+1) % n]] = False
                        break

                if not improved_i:
                    dont_look[tour[i]] = True

        return tour
=======
    def two_opt_pass(tour, deadline):
        """2-opt with don't-look bits and neighbor list acceleration."""
        tour = list(tour)
        improved = True
        dont_look = [False] * n

        # Build position lookup for fast neighbor-based 2-opt
        pos = [0] * n
        for idx in range(n):
            pos[tour[idx]] = idx

        while improved and time.perf_counter() < deadline:
            improved = False
            for i in range(n):
                if dont_look[tour[i]]:
                    continue
                if time.perf_counter() >= deadline:
                    break

                improved_i = False
                a = tour[i]
                b = tour[(i + 1) % n]

                # First check k-nearest neighbors of city a for potential improvements
                for c in neighbor_list[a]:
                    j = pos[c]
                    if j == i or j == (i + 1) % n:
                        continue

                    # Ensure proper ordering for 2-opt
                    if j < i:
                        ii, jj = j, i
                    else:
                        ii, jj = i, j

                    if jj == n - 1 and ii == 0:
                        continue

                    aa, bb = tour[ii], tour[(ii + 1) % n]
                    cc, dd = tour[jj], tour[(jj + 1) % n]
                    delta = (dist[aa, cc] + dist[bb, dd]) - (dist[aa, bb] + dist[cc, dd])

                    if delta < -0.5:
                        tour[ii+1:jj+1] = tour[ii+1:jj+1][::-1]
                        # Update positions
                        for k in range(ii+1, jj+1):
                            pos[tour[k]] = k
                        improved = True
                        improved_i = True
                        dont_look[aa] = False
                        dont_look[bb] = False
                        dont_look[cc] = False
                        dont_look[dd] = False
                        break

                # If no improvement from neighbors, try standard 2-opt with sampling
                if not improved_i:
                    step = max(1, n // 30)
                    for j in range(i + 2, n, step):
                        if j == n - 1 and i == 0:
                            continue

                        aa, bb = tour[i], tour[(i + 1) % n]
                        cc, dd = tour[j], tour[(j + 1) % n]
                        delta = (dist[aa, cc] + dist[bb, dd]) - (dist[aa, bb] + dist[cc, dd])

                        if delta < -0.5:
                            tour[i+1:j+1] = tour[i+1:j+1][::-1]
                            for k in range(i+1, j+1):
                                pos[tour[k]] = k
                            improved = True
                            improved_i = True
                            dont_look[aa] = False
                            dont_look[bb] = False
                            dont_look[cc] = False
                            dont_look[dd] = False
                            break

                if not improved_i:
                    dont_look[tour[i]] = True

        return tour
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Phase 1: Multi-start construction (15% of time)
    construction_deadline = start_time + (time_limit_ms / 1000.0) * 0.15

    num_starts = min(n, 20)
    if n <= 30:
        start_cities = list(range(n))
    else:
        start_cities = [int(i * n / num_starts) for i in range(num_starts)]

    best_tour = None
    best_length = np.inf

    for start in start_cities:
        if time.perf_counter() >= construction_deadline:
            break
        tour = nearest_neighbor_fast(start)
        length = calc_tour_length(tour)
        if length < best_length:
            best_length = length
            best_tour = tour[:]

    if best_tour is None:
        best_tour = nearest_neighbor_fast(0)
=======
    # Phase 1: Multi-start construction (12% of time)
    construction_deadline = start_time + (time_limit_ms / 1000.0) * 0.12

    num_starts = min(n, 15)
    if n <= 30:
        start_cities = list(range(n))
    else:
        start_cities = [int(i * n / num_starts) for i in range(num_starts)]

    best_tour = None
    best_length = np.inf

    # Try farthest insertion first
    if time.perf_counter() < construction_deadline:
        fi_tour = farthest_insertion()
        if len(fi_tour) == n:
            length = calc_tour_length(fi_tour)
            if length < best_length:
                best_length = length
                best_tour = fi_tour[:]

    for start in start_cities:
        if time.perf_counter() >= construction_deadline:
            break
        tour = nearest_neighbor_fast(start)
        length = calc_tour_length(tour)
        if length < best_length:
            best_length = length
            best_tour = tour[:]

    if best_tour is None:
        best_tour = nearest_neighbor_fast(0)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Occasional perturbation for diversification (iterated local search)
        if iteration % 4 == 0 and time.perf_counter() < deadline - 0.2:
            # Save current best and try perturbation
            perturbed = perturb_tour(tour)

            # Quick 2-opt on perturbed tour
            mini_deadline = time.perf_counter() + 0.1
            perturbed = two_opt_pass(perturbed, mini_deadline)

            perturbed_length = calc_tour_length(perturbed)

            # Accept if better than current (greedy acceptance)
            if perturbed_length < calc_tour_length(tour):
                tour = perturbed

            if perturbed_length < best_overall_length:
                best_overall_length = perturbed_length
                best_overall_tour = perturbed[:]
=======
        # Occasional perturbation for diversification (iterated local search)
        if iteration % 3 == 0 and time.perf_counter() < deadline - 0.15:
            # Save current best and try perturbation
            perturbed = perturb_tour(best_overall_tour)

            # Quick 2-opt on perturbed tour
            mini_deadline = time.perf_counter() + 0.08
            perturbed = two_opt_pass(perturbed, mini_deadline)

            perturbed_length = calc_tour_length(perturbed)

            # Simulated annealing-style acceptance
            current_tour_length = calc_tour_length(tour)

            # Accept if better, or with probability based on quality gap
            if perturbed_length < current_tour_length:
                tour = perturbed
            elif perturbed_length < current_tour_length * 1.02:  # Accept up to 2% worse
                # Accept with decreasing probability as iterations increase
                accept_prob = max(0.1, 0.5 - iteration * 0.02)
                if random.random() < accept_prob:
                    tour = perturbed

            if perturbed_length < best_overall_length:
                best_overall_length = perturbed_length
                best_overall_tour = perturbed[:]
>>>>>>> REPLACE
</DIFF>